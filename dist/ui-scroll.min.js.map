{"version":3,"sources":["webpack:///ui-scroll.min.js","webpack:///webpack/bootstrap 2386088bf7ce5bf5d4af","webpack:///./src/ui-scroll.js","webpack:///./src/modules/jqLiteExtras.js","webpack:///./src/modules/elementRoutines.js","webpack:///./src/modules/buffer.js","webpack:///./src/modules/viewport.js","webpack:///./src/modules/padding.js","webpack:///./src/modules/adapter.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_interopRequireDefault","obj","default","_jqLiteExtras","_jqLiteExtras2","_elementRoutines","_elementRoutines2","_buffer","_buffer2","_viewport","_viewport2","_adapter","_adapter2","angular","constant","JQLiteExtras","run","window","jQuery","registerFor","element","ElementRoutines","addCSSRules","directive","restrict","controller","scope","_this","this","container","viewport","forEach","children","child","tagName","toLowerCase","console","$injector","$rootScope","$timeout","$interval","$q","$parse","link","$scope","$attr","controllers","linker","parseNumericAttr","value","defaultValue","result","isNaN","onRenderHandlersRunner","onRenderHandlers","handler","persistDatasourceIndex","datasource","propName","isNumber","filter","id","push","defineDatasourceIndex","propUserName","descriptor","getOwnPropertyDescriptor","set","pending","length","buffer","topPaddingHeightOld","topDataPos","adjustPaddings","onAfterMinIndexSet","isInvalid","rid","ridActual","$$destroyed","bindEvents","bind","resizeAndScrollHandler","unbindEvents","unbind","reload","resetTopPadding","resetBottomPadding","arguments","startIndex","reset","doAdjust","isElementVisible","wrapper","height","offsetParent","visibilityWatcher","item","unregisterVisibilityWatcher","insertWrapperContent","insertAfter","createElement","insertElement","$watch","elementRoutines","hideElement","promises","sibling","undefined","clone","itemName","adapter","transform","tdInitializer","uiScrollTdInitializer","linking","onLink","updateDOM","toBePrepended","toBeRemoved","inserted","op","unshift","concat","insertElementAnimated","removeItem","$index","first","prepended","removed","animated","updatePaddings","updates","all","then","enqueueFetch","shouldLoadBottom","effectiveHeight","loading","fetch","shouldLoadTop","processUpdates","$$phase","$digest","w","showElement","calculateProperties","doAdjustAfterFetch","onAfterPrepend","shift","fetchNext","bufferSize","eof","clipTop","append","fetchPrevious","bof","clipBottom","prepend","ev","isLoading","disabled","type","scrollTop","scrollTopValue","scrollTopSetFailed","curScrollTop","Math","abs","scrollTopBeforeSet","scrollTopAdjust","wheelHandler","event","yMax","scrollHeight","clientHeight","preventDefault","match","uiScroll","Error","datasourceName","viewportController","max","padding","ScrollBuffer","Viewport","Adapter","isDatasourceValid","toString","success","next","index","count","createPaddingElements","$destroy","remove","$on","tryCount","applyContainerStyle","timer","cancel","require","transclude","priority","terminal","_classCallCheck","instance","Constructor","TypeError","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","Symbol","iterator","done","err","Array","isArray","_createClass","defineProperties","target","props","writable","key","protoProps","staticProps","scrollTo","self","direction","elem","_top$left$direction","top","left","method","prop","preserve","isValueDefined","isWindow","document","documentElement","getMeasurements","measure","base","borderA","borderB","computedMarginA","computedMarginB","computedStyle","dirA","dirB","marginA","marginB","paddingA","paddingB","width","border","margin","_width$height$measure","offsetWidth","offsetHeight","getStyle","convertToPx","getWidthHeight","measurements","outer","outerfull","style","parseFloat","css","nodeType","location","alert","setInterval","getComputedStyle","currentStyle","rs","rsLeft","core_pnum","source","RegExp","test","runtimeStyle","pixelLeft","before","newElem","j","parent","ref","contents","after","outerHTML","outerHeight","option","outerWidth","offset","docElem","win","box","doc","ownerDocument","getBoundingClientRect","defaultView","parentWindow","pageYOffset","clientTop","pageXOffset","scrollLeft","clientLeft","$animate","has","isAngularVersionLessThen1_3","version","major","minor","sheet","styleSheets","cssRules","insertRule","selector","addRule","addClass","removeClass","newElement","previousElement","deferred","defer","enter","resolve","promise","removeElement","leave","create","extend","size","minIndex","maxIndex","minIndexUser","maxIndexUser","items","insert","reverse","min","operation","isTop","splice","arg1","arg2","indexOf","_op","getAbsMinIndex","incrementMinIndex","decrementMaxIndex","removeElementAnimated","getAbsMaxIndex","elements","Number","MAX_VALUE","bottom","NEGATIVE_INFINITY","bufferPadding","topPadding","bottomPadding","overflow-anchor","overflow-y","display","scrollTopOriginal","getScope","apply","template","Padding","bottomDataPos","bottomVisiblePos","topVisiblePos","e","overage","overageHeight","itemHeight","emptySpaceHeight","cache","add","visibleItemsHeight","reduce","summ","topPaddingHeight","topCount","bottomPaddingHeight","bottomCount","totalHeight","averageItemHeight","adjustTopPadding","adjustBottomPadding","topPaddingHeightAdd","bottomPaddingHeightAdd","diff","paddingHeight","clear","removeCacheItem","_padding","_padding2","Cache","setPrototypeOf","generateElement","Node","ELEMENT_NODE","find","CacheProto","sort","a","b","argument","_isTop","getOwnPropertyNames","methodName","viewportScope","startScope","$parent","publicContext","assignAdapter","generatePublicContext","adapterAttr","replace","adapterOnScope","assign","error","message","publicMethods","publicProps","attr","newItems","applyUpdatesFunc","applyUpdatesIndex","cb","_this2","slice","applyUpdate","_index","_this3","position","some","newItem","rowTop","topHeight","topDone","bottomDone","itemTop","isEOF"],"mappings":"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","file":"ui-scroll.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _jqLiteExtras = __webpack_require__(1);\n\nvar _jqLiteExtras2 = _interopRequireDefault(_jqLiteExtras);\n\nvar _elementRoutines = __webpack_require__(2);\n\nvar _elementRoutines2 = _interopRequireDefault(_elementRoutines);\n\nvar _buffer = __webpack_require__(3);\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nvar _viewport = __webpack_require__(4);\n\nvar _viewport2 = _interopRequireDefault(_viewport);\n\nvar _adapter = __webpack_require__(6);\n\nvar _adapter2 = _interopRequireDefault(_adapter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nangular.module('ui.scroll', []).constant('JQLiteExtras', _jqLiteExtras2.default).run(['JQLiteExtras', function (JQLiteExtras) {\n  !window.jQuery ? new JQLiteExtras().registerFor(angular.element) : null;\n  _elementRoutines2.default.addCSSRules();\n}]).directive('uiScrollViewport', function () {\n  return {\n    restrict: 'A',\n    controller: ['$scope', '$element', function (scope, element) {\n      var _this = this;\n\n      this.container = element;\n      this.viewport = element;\n      this.scope = scope;\n\n      angular.forEach(element.children(), function (child) {\n        if (child.tagName.toLowerCase() === 'tbody') {\n          _this.viewport = angular.element(child);\n        }\n      });\n\n      return this;\n    }]\n  };\n}).directive('uiScroll', ['$log', '$injector', '$rootScope', '$timeout', '$interval', '$q', '$parse', function (console, $injector, $rootScope, $timeout, $interval, $q, $parse) {\n\n  return {\n    require: ['?^uiScrollViewport'],\n    restrict: 'A',\n    transclude: 'element',\n    priority: 1000,\n    terminal: true,\n    link: link\n  };\n\n  function link($scope, element, $attr, controllers, linker) {\n    var match = $attr.uiScroll.match(/^\\s*(\\w+)\\s+in\\s+([(\\w|\\$)\\.]+)\\s*$/);\n    if (!match) {\n      throw new Error('Expected uiScroll in form of \\'_item_ in _datasource_\\' but got \\'' + $attr.uiScroll + '\\'');\n    }\n\n    function parseNumericAttr(value, defaultValue) {\n      var result = $parse(value)($scope);\n      return isNaN(result) ? defaultValue : result;\n    }\n\n    var BUFFER_MIN = 3;\n    var BUFFER_DEFAULT = 10;\n    var PADDING_MIN = 0.01;\n    var PADDING_DEFAULT = 0.5;\n    var MAX_VIEWPORT_DELAY = 500;\n    var VIEWPORT_POLLING_INTERVAL = 50;\n\n    var datasource = null;\n    var itemName = match[1];\n    var datasourceName = match[2];\n    var viewportController = controllers[0];\n    var bufferSize = Math.max(BUFFER_MIN, parseNumericAttr($attr.bufferSize, BUFFER_DEFAULT));\n    var padding = Math.max(PADDING_MIN, parseNumericAttr($attr.padding, PADDING_DEFAULT));\n    var startIndex = parseNumericAttr($attr.startIndex, 1);\n    var ridActual = 0; // current data revision id\n    var pending = [];\n\n    var elementRoutines = new _elementRoutines2.default($injector, $q);\n    var buffer = new _buffer2.default(elementRoutines, bufferSize, startIndex);\n    var viewport = new _viewport2.default(elementRoutines, buffer, element, viewportController, $rootScope, padding);\n    var adapter = new _adapter2.default($scope, $parse, $attr, viewport, buffer, doAdjust, reload);\n\n    if (viewportController) {\n      viewportController.adapter = adapter;\n    }\n\n    var isDatasourceValid = function isDatasourceValid() {\n      return Object.prototype.toString.call(datasource) === '[object Object]' && typeof datasource.get === 'function';\n    };\n\n    datasource = $parse(datasourceName)($scope); // try to get datasource on scope\n    if (!isDatasourceValid()) {\n      datasource = $injector.get(datasourceName); // try to inject datasource as service\n      if (!isDatasourceValid()) {\n        throw new Error(datasourceName + ' is not a valid datasource');\n      }\n    }\n\n    var onRenderHandlers = [];\n    function onRenderHandlersRunner() {\n      onRenderHandlers.forEach(function (handler) {\n        return handler.run();\n      });\n      onRenderHandlers = [];\n    }\n    function persistDatasourceIndex(datasource, propName) {\n      var getter = void 0;\n      // need to postpone min/maxIndexUser processing if the view is empty\n      if (angular.isNumber(datasource[propName])) {\n        getter = datasource[propName];\n        if (angular.isNumber(getter)) {\n          onRenderHandlers = onRenderHandlers.filter(function (handler) {\n            return handler.id !== propName;\n          });\n          onRenderHandlers.push({\n            id: propName,\n            run: function run() {\n              return datasource[propName] = getter;\n            }\n          });\n        }\n      }\n    }\n\n    function defineDatasourceIndex(datasource, propName, propUserName) {\n      var descriptor = Object.getOwnPropertyDescriptor(datasource, propName);\n      if (descriptor && (descriptor.set || descriptor.get)) {\n        return;\n      }\n      var getter = void 0;\n      persistDatasourceIndex(datasource, propName);\n      Object.defineProperty(datasource, propName, {\n        set: function set(value) {\n          getter = value;\n          if (pending.length && !buffer.length) {\n            persistDatasourceIndex(datasource, propName);\n            return;\n          }\n          buffer[propUserName] = value;\n          var topPaddingHeightOld = viewport.topDataPos();\n          viewport.adjustPaddings();\n          if (propName === 'minIndex') {\n            viewport.onAfterMinIndexSet(topPaddingHeightOld);\n          }\n        },\n        get: function get() {\n          return getter;\n        }\n      });\n    }\n\n    defineDatasourceIndex(datasource, 'minIndex', 'minIndexUser');\n    defineDatasourceIndex(datasource, 'maxIndex', 'maxIndexUser');\n\n    var fetchNext = datasource.get.length !== 2 ? function (success) {\n      return datasource.get(buffer.next, bufferSize, success);\n    } : function (success) {\n      datasource.get({\n        index: buffer.next,\n        append: buffer.length ? buffer[buffer.length - 1].item : void 0,\n        count: bufferSize\n      }, success);\n    };\n\n    var fetchPrevious = datasource.get.length !== 2 ? function (success) {\n      return datasource.get(buffer.first - bufferSize, bufferSize, success);\n    } : function (success) {\n      datasource.get({\n        index: buffer.first - bufferSize,\n        prepend: buffer.length ? buffer[0].item : void 0,\n        count: bufferSize\n      }, success);\n    };\n\n    var initialize = function initialize() {\n      var tryCount = 0;\n      if (!viewport.applyContainerStyle()) {\n        var timer = $interval(function () {\n          tryCount++;\n          if (viewport.applyContainerStyle()) {\n            $interval.cancel(timer);\n            doAdjust();\n          }\n          if (tryCount * VIEWPORT_POLLING_INTERVAL >= MAX_VIEWPORT_DELAY) {\n            $interval.cancel(timer);\n            throw Error('ui-scroll directive requires a viewport with non-zero height in ' + MAX_VIEWPORT_DELAY + 'ms');\n          }\n        }, VIEWPORT_POLLING_INTERVAL);\n      } else {\n        doAdjust();\n      }\n    };\n\n    /**\n     * Build padding elements\n     *\n     * Calling linker is the only way I found to get access to the tag name of the template\n     * to prevent the directive scope from pollution a new scope is created and destroyed\n     * right after the builder creation is completed\n     */\n    linker(function (clone, scope) {\n      viewport.createPaddingElements(clone[0]);\n      // we do not include the clone in the DOM. It means that the nested directives will not\n      // be able to reach the parent directives, but in this case it is intentional because we\n      // created the clone to access the template tag name\n      scope.$destroy();\n      clone.remove();\n    });\n\n    $scope.$on('$destroy', function () {\n      unbindEvents();\n      viewport.unbind('mousewheel', wheelHandler);\n    });\n\n    viewport.bind('mousewheel', wheelHandler);\n\n    initialize();\n\n    /* Private function definitions */\n\n    function isInvalid(rid) {\n      return rid && rid !== ridActual || $scope.$$destroyed;\n    }\n\n    function bindEvents() {\n      viewport.bind('resize', resizeAndScrollHandler);\n      viewport.bind('scroll', resizeAndScrollHandler);\n    }\n\n    function unbindEvents() {\n      viewport.unbind('resize', resizeAndScrollHandler);\n      viewport.unbind('scroll', resizeAndScrollHandler);\n    }\n\n    function reload() {\n      viewport.resetTopPadding();\n      viewport.resetBottomPadding();\n      if (arguments.length) {\n        startIndex = arguments[0];\n      }\n      buffer.reset(startIndex);\n      persistDatasourceIndex(datasource, 'minIndex');\n      persistDatasourceIndex(datasource, 'maxIndex');\n      doAdjust();\n    }\n\n    function isElementVisible(wrapper) {\n      return wrapper.element.height() && wrapper.element[0].offsetParent;\n    }\n\n    function visibilityWatcher(wrapper) {\n      if (isElementVisible(wrapper)) {\n        buffer.forEach(function (item) {\n          if (typeof item.unregisterVisibilityWatcher === 'function') {\n            item.unregisterVisibilityWatcher();\n            delete item.unregisterVisibilityWatcher;\n          }\n        });\n        if (!pending.length) {\n          $timeout(function () {\n            return doAdjust();\n          });\n        }\n      }\n    }\n\n    function insertWrapperContent(wrapper, insertAfter) {\n      createElement(wrapper, insertAfter, viewport.insertElement);\n      if (!isElementVisible(wrapper)) {\n        wrapper.unregisterVisibilityWatcher = wrapper.scope.$watch(function () {\n          return visibilityWatcher(wrapper);\n        });\n      }\n      elementRoutines.hideElement(wrapper); // hide inserted elements before data binding\n    }\n\n    function createElement(wrapper, insertAfter, insertElement) {\n      var promises = null;\n      var sibling = insertAfter > 0 ? buffer[insertAfter - 1].element : undefined;\n      linker(function (clone, scope) {\n        promises = insertElement(clone, sibling);\n        wrapper.element = clone;\n        wrapper.scope = scope;\n        scope[itemName] = wrapper.item;\n      });\n      // ui-scroll-grid apply\n      if (adapter.transform) {\n        var tdInitializer = wrapper.scope.uiScrollTdInitializer;\n        if (tdInitializer && tdInitializer.linking) {\n          adapter.transform(wrapper.scope, wrapper.element);\n        } else {\n          wrapper.scope.uiScrollTdInitializer = {\n            onLink: function onLink() {\n              return adapter.transform(wrapper.scope, wrapper.element);\n            },\n            scope: wrapper.scope\n          };\n        }\n      }\n      return promises;\n    }\n\n    function updateDOM() {\n      var promises = [];\n      var toBePrepended = [];\n      var toBeRemoved = [];\n      var inserted = [];\n\n      buffer.forEach(function (wrapper, i) {\n        switch (wrapper.op) {\n          case 'prepend':\n            toBePrepended.unshift(wrapper);\n            break;\n          case 'append':\n            insertWrapperContent(wrapper, i);\n            wrapper.op = 'none';\n            inserted.push(wrapper);\n            break;\n          case 'insert':\n            promises = promises.concat(createElement(wrapper, i, viewport.insertElementAnimated));\n            wrapper.op = 'none';\n            inserted.push(wrapper);\n            break;\n          case 'remove':\n            toBeRemoved.push(wrapper);\n        }\n      });\n\n      toBeRemoved.forEach(function (wrapper) {\n        return promises = promises.concat(viewport.removeItem(wrapper));\n      });\n\n      if (toBePrepended.length) toBePrepended.forEach(function (wrapper) {\n        insertWrapperContent(wrapper);\n        wrapper.op = 'none';\n      });\n\n      buffer.forEach(function (item, i) {\n        return item.scope.$index = buffer.first + i;\n      });\n\n      return {\n        prepended: toBePrepended,\n        removed: toBeRemoved,\n        inserted: inserted,\n        animated: promises\n      };\n    }\n\n    function updatePaddings(rid, updates) {\n      // schedule another doAdjust after animation completion\n      if (updates.animated.length) {\n        $q.all(updates.animated).then(function () {\n          viewport.adjustPaddings();\n          doAdjust(rid);\n        });\n      } else {\n        viewport.adjustPaddings();\n      }\n    }\n\n    function enqueueFetch(rid, updates) {\n      if (viewport.shouldLoadBottom()) {\n        if (!updates || buffer.effectiveHeight(updates.inserted) > 0) {\n          // this means that at least one item appended in the last batch has height > 0\n          if (pending.push(true) === 1) {\n            adapter.loading(true);\n            fetch(rid);\n          }\n        }\n      } else if (viewport.shouldLoadTop()) {\n        if (!updates || buffer.effectiveHeight(updates.prepended) > 0 || pending[0]) {\n          // this means that at least one item appended in the last batch has height > 0\n          // pending[0] = true means that previous fetch was appending. We need to force at least one prepend\n          // BTW there will always be at least 1 element in the pending array because bottom is fetched first\n          if (pending.push(false) === 1) {\n            adapter.loading(true);\n            fetch(rid);\n          }\n        }\n      }\n    }\n\n    function processUpdates() {\n      var updates = updateDOM();\n\n      // We need the item bindings to be processed before we can do adjustments\n      !$scope.$$phase && !$rootScope.$$phase && $scope.$digest();\n\n      updates.inserted.forEach(function (w) {\n        return elementRoutines.showElement(w);\n      });\n      updates.prepended.forEach(function (w) {\n        return elementRoutines.showElement(w);\n      });\n      return updates;\n    }\n\n    function doAdjust(rid) {\n      if (!rid) {\n        // dismiss pending requests\n        pending = [];\n        rid = ++ridActual;\n      }\n\n      var updates = processUpdates();\n\n      if (isInvalid(rid)) {\n        return;\n      }\n\n      updatePaddings(rid, updates);\n      enqueueFetch(rid);\n\n      if (!pending.length) {\n        adapter.calculateProperties();\n      }\n    }\n\n    function doAdjustAfterFetch(rid) {\n      var updates = processUpdates();\n\n      viewport.onAfterPrepend(updates);\n\n      if (isInvalid(rid)) {\n        return;\n      }\n\n      updatePaddings(rid, updates);\n      onRenderHandlersRunner();\n      enqueueFetch(rid, updates);\n      pending.shift();\n\n      if (pending.length) fetch(rid);else {\n        adapter.loading(false);\n        bindEvents();\n        adapter.calculateProperties();\n      }\n    }\n\n    function fetch(rid) {\n      if (pending[0]) {\n        // scrolling down\n        if (buffer.length && !viewport.shouldLoadBottom()) {\n          doAdjustAfterFetch(rid);\n        } else {\n          fetchNext(function (result) {\n            if (isInvalid(rid)) {\n              return;\n            }\n\n            if (result.length < bufferSize) {\n              buffer.eof = true;\n            }\n\n            if (result.length > 0) {\n              viewport.clipTop();\n              buffer.append(result);\n            }\n\n            doAdjustAfterFetch(rid);\n          });\n        }\n      } else {\n        // scrolling up\n        if (buffer.length && !viewport.shouldLoadTop()) {\n          doAdjustAfterFetch(rid);\n        } else {\n          fetchPrevious(function (result) {\n            if (isInvalid(rid)) {\n              return;\n            }\n\n            if (result.length < bufferSize) {\n              buffer.bof = true;\n              // log 'bof is reached'\n            }\n\n            if (result.length > 0) {\n              if (buffer.length) {\n                viewport.clipBottom();\n              }\n              buffer.prepend(result);\n            }\n\n            doAdjustAfterFetch(rid);\n          });\n        }\n      }\n    }\n\n    function resizeAndScrollHandler(ev) {\n      if ($rootScope.$$phase || adapter.isLoading || adapter.disabled) {\n        return;\n      }\n\n      if (ev.type === 'scroll') {\n        // Don't process scroll event if it was triggered by us setting scrollTop.\n        if (viewport[0].scrollTop === viewport.scrollTopValue) {\n          return false;\n        }\n\n        // Check if we tried to set scrollTop and it failed. If that happens, don't prepend more items based on the stale value\n        // of scrollTop that will be used by shouldLoadTop(). Also, try to set it again.\n        viewport.scrollTopSetFailed = false;\n        if (viewport.scrollTopValue != null) {\n          var curScrollTop = viewport[0].scrollTop;\n          if (Math.abs(curScrollTop - viewport.scrollTopValue) > Math.abs(curScrollTop - viewport.scrollTopBeforeSet)) {\n            viewport.scrollTopSetFailed = true;\n            viewport.scrollTop(curScrollTop - viewport.scrollTopAdjust);\n          }\n        }\n      }\n\n      enqueueFetch(ridActual);\n\n      // we got a real scroll event, so browser is now in charge of scrollTop\n      viewport.scrollTopValue = null;\n\n      if (pending.length) {\n        unbindEvents();\n      } else {\n        adapter.calculateProperties();\n        !$scope.$$phase && $scope.$digest();\n      }\n    }\n\n    function wheelHandler(event) {\n      if (!adapter.disabled) {\n        var scrollTop = viewport[0].scrollTop;\n        var yMax = viewport[0].scrollHeight - viewport[0].clientHeight;\n\n        if (scrollTop === 0 && !buffer.bof || scrollTop === yMax && !buffer.eof) {\n          event.preventDefault();\n        }\n      }\n    }\n  }\n}]);\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*!\r\n globals: angular, window\r\n List of used element methods available in JQuery but not in JQuery Lite\r\n element.before(elem)\r\n element.height()\r\n element.outerHeight(true)\r\n element.height(value) = only for Top/Bottom padding elements\r\n element.scrollTop()\r\n element.scrollTop(value)\r\n */\n\nvar JQLiteExtras = function () {\n  function JQLiteExtras() {\n    _classCallCheck(this, JQLiteExtras);\n  }\n\n  _createClass(JQLiteExtras, [{\n    key: 'registerFor',\n    value: function registerFor(element) {\n      var convertToPx = void 0,\n          css = void 0,\n          getStyle = void 0,\n          isWindow = void 0;\n      // angular implementation blows up if elem is the window\n      css = angular.element.prototype.css;\n\n      element.prototype.css = function (name, value) {\n        var self = this;\n        var elem = self[0];\n        if (!(!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style)) {\n          return css.call(self, name, value);\n        }\n      };\n\n      // as defined in angularjs v1.0.5\n      isWindow = function isWindow(obj) {\n        return obj && obj.document && obj.location && obj.alert && obj.setInterval;\n      };\n\n      function scrollTo(self, direction, value) {\n        var elem = self[0];\n\n        var _top$left$direction = _slicedToArray({\n          top: ['scrollTop', 'pageYOffset', 'scrollLeft'],\n          left: ['scrollLeft', 'pageXOffset', 'scrollTop']\n        }[direction], 3),\n            method = _top$left$direction[0],\n            prop = _top$left$direction[1],\n            preserve = _top$left$direction[2];\n\n        var isValueDefined = typeof value !== 'undefined';\n        if (isWindow(elem)) {\n          if (isValueDefined) {\n            return elem.scrollTo(self[preserve].call(self), value);\n          }\n          return prop in elem ? elem[prop] : elem.document.documentElement[method];\n        } else {\n          if (isValueDefined) {\n            elem[method] = value;\n          }\n          return elem[method];\n        }\n      }\n\n      if (window.getComputedStyle) {\n        getStyle = function getStyle(elem) {\n          return window.getComputedStyle(elem, null);\n        };\n        convertToPx = function convertToPx(elem, value) {\n          return parseFloat(value);\n        };\n      } else {\n        getStyle = function getStyle(elem) {\n          return elem.currentStyle;\n        };\n        convertToPx = function convertToPx(elem, value) {\n          var left = void 0,\n              result = void 0,\n              rs = void 0,\n              rsLeft = void 0,\n              style = void 0;\n          var core_pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\n          var rnumnonpx = new RegExp('^(' + core_pnum + ')(?!px)[a-z%]+$', 'i');\n\n          if (!rnumnonpx.test(value)) {\n            return parseFloat(value);\n          }\n\n          // ported from JQuery\n          style = elem.style;\n          left = style.left;\n          rs = elem.runtimeStyle;\n          rsLeft = rs && rs.left;\n          if (rs) {\n            rs.left = style.left;\n          }\n          // put in the new values to get a computed style out\n          style.left = value;\n          result = style.pixelLeft;\n          style.left = left;\n          if (rsLeft) {\n            rs.left = rsLeft;\n          }\n          return result;\n        };\n      }\n\n      function getMeasurements(elem, measure) {\n        var base = void 0,\n            borderA = void 0,\n            borderB = void 0,\n            computedMarginA = void 0,\n            computedMarginB = void 0,\n            computedStyle = void 0,\n            dirA = void 0,\n            dirB = void 0,\n            marginA = void 0,\n            marginB = void 0,\n            paddingA = void 0,\n            paddingB = void 0;\n\n        if (isWindow(elem)) {\n          base = document.documentElement[{ height: 'clientHeight', width: 'clientWidth' }[measure]];\n\n          return {\n            base: base,\n            padding: 0,\n            border: 0,\n            margin: 0\n          };\n        }\n\n        // Start with offset property\n\n        var _width$height$measure = _slicedToArray({\n          width: [elem.offsetWidth, 'Left', 'Right'],\n          height: [elem.offsetHeight, 'Top', 'Bottom']\n        }[measure], 3);\n\n        base = _width$height$measure[0];\n        dirA = _width$height$measure[1];\n        dirB = _width$height$measure[2];\n\n\n        computedStyle = getStyle(elem);\n        paddingA = convertToPx(elem, computedStyle['padding' + dirA]) || 0;\n        paddingB = convertToPx(elem, computedStyle['padding' + dirB]) || 0;\n        borderA = convertToPx(elem, computedStyle['border' + dirA + 'Width']) || 0;\n        borderB = convertToPx(elem, computedStyle['border' + dirB + 'Width']) || 0;\n        computedMarginA = computedStyle['margin' + dirA];\n        computedMarginB = computedStyle['margin' + dirB];\n\n        // I do not care for width for now, so this hack is irrelevant\n        // if ( !supportsPercentMargin )\n        // computedMarginA = hackPercentMargin( elem, computedStyle, computedMarginA )\n        // computedMarginB = hackPercentMargin( elem, computedStyle, computedMarginB )\n        marginA = convertToPx(elem, computedMarginA) || 0;\n        marginB = convertToPx(elem, computedMarginB) || 0;\n\n        return {\n          base: base,\n          padding: paddingA + paddingB,\n          border: borderA + borderB,\n          margin: marginA + marginB\n        };\n      }\n\n      function getWidthHeight(elem, direction, measure) {\n        var computedStyle = void 0,\n            result = void 0;\n\n        var measurements = getMeasurements(elem, direction);\n\n        if (measurements.base > 0) {\n          return {\n            base: measurements.base - measurements.padding - measurements.border,\n            outer: measurements.base,\n            outerfull: measurements.base + measurements.margin\n          }[measure];\n        }\n\n        // Fall back to computed then uncomputed css if necessary\n        computedStyle = getStyle(elem);\n        result = computedStyle[direction];\n\n        if (result < 0 || result === null) {\n          result = elem.style[direction] || 0;\n        }\n\n        // Normalize \"\", auto, and prepare for extra\n        result = parseFloat(result) || 0;\n\n        return {\n          base: result - measurements.padding - measurements.border,\n          outer: result,\n          outerfull: result + measurements.padding + measurements.border + measurements.margin\n        }[measure];\n      }\n\n      // define missing methods\n      return angular.forEach({\n        before: function before(newElem) {\n          var children, elem, i, j, parent, ref, self;\n          self = this;\n          elem = self[0];\n          parent = self.parent();\n          children = parent.contents();\n          if (children[0] === elem) {\n            return parent.prepend(newElem);\n          } else {\n            for (i = j = 1, ref = children.length - 1; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {\n              if (children[i] === elem) {\n                angular.element(children[i - 1]).after(newElem);\n                return;\n              }\n            }\n            throw new Error('invalid DOM structure ' + elem.outerHTML);\n          }\n        },\n        height: function height(value) {\n          var self;\n          self = this;\n          if (typeof value !== 'undefined') {\n            if (angular.isNumber(value)) {\n              value = value + 'px';\n            }\n            return css.call(self, 'height', value);\n          } else {\n            return getWidthHeight(this[0], 'height', 'base');\n          }\n        },\n        outerHeight: function outerHeight(option) {\n          return getWidthHeight(this[0], 'height', option ? 'outerfull' : 'outer');\n        },\n        outerWidth: function outerWidth(option) {\n          return getWidthHeight(this[0], 'width', option ? 'outerfull' : 'outer');\n        },\n\n\n        /*\r\n         The offset setter method is not implemented\r\n         */\n        offset: function offset(value) {\n          var docElem = void 0,\n              win = void 0;\n          var self = this;\n          var box = {\n            top: 0,\n            left: 0\n          };\n          var elem = self[0];\n          var doc = elem && elem.ownerDocument;\n\n          if (arguments.length) {\n            if (value === undefined) {\n              return self;\n            }\n            // TODO: implement setter\n            throw new Error('offset setter method is not implemented');\n          }\n\n          if (!doc) {\n            return;\n          }\n\n          docElem = doc.documentElement;\n\n          // TODO: Make sure it's not a disconnected DOM node\n\n          if (elem.getBoundingClientRect != null) {\n            box = elem.getBoundingClientRect();\n          }\n\n          win = doc.defaultView || doc.parentWindow;\n\n          return {\n            top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),\n            left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)\n          };\n        },\n        scrollTop: function scrollTop(value) {\n          return scrollTo(this, 'top', value);\n        },\n        scrollLeft: function scrollLeft(value) {\n          return scrollTo(this, 'left', value);\n        }\n      }, function (value, key) {\n        if (!element.prototype[key]) {\n          return element.prototype[key] = value;\n        }\n      });\n    }\n  }]);\n\n  return JQLiteExtras;\n}();\n\nexports.default = JQLiteExtras;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar hideClassToken = 'ng-ui-scroll-hide';\n\nvar ElementRoutines = function () {\n  _createClass(ElementRoutines, null, [{\n    key: 'addCSSRules',\n    value: function addCSSRules() {\n      var selector = '.' + hideClassToken;\n      var rules = 'display: none';\n      var sheet = document.styleSheets[0];\n      var index = void 0;\n      try {\n        index = sheet.cssRules.length;\n      } catch (err) {\n        index = 0;\n      }\n      if ('insertRule' in sheet) {\n        sheet.insertRule(selector + '{' + rules + '}', index);\n      } else if ('addRule' in sheet) {\n        sheet.addRule(selector, rules, index);\n      }\n    }\n  }]);\n\n  function ElementRoutines($injector, $q) {\n    _classCallCheck(this, ElementRoutines);\n\n    this.$animate = $injector.has && $injector.has('$animate') ? $injector.get('$animate') : null;\n    this.isAngularVersionLessThen1_3 = angular.version.major === 1 && angular.version.minor < 3;\n    this.$q = $q;\n  }\n\n  _createClass(ElementRoutines, [{\n    key: 'hideElement',\n    value: function hideElement(wrapper) {\n      wrapper.element.addClass(hideClassToken);\n    }\n  }, {\n    key: 'showElement',\n    value: function showElement(wrapper) {\n      wrapper.element.removeClass(hideClassToken);\n    }\n  }, {\n    key: 'insertElement',\n    value: function insertElement(newElement, previousElement) {\n      previousElement.after(newElement);\n      return [];\n    }\n  }, {\n    key: 'removeElement',\n    value: function removeElement(wrapper) {\n      wrapper.element.remove();\n      wrapper.scope.$destroy();\n      return [];\n    }\n  }, {\n    key: 'insertElementAnimated',\n    value: function insertElementAnimated(newElement, previousElement) {\n      if (!this.$animate) {\n        return this.insertElement(newElement, previousElement);\n      }\n\n      if (this.isAngularVersionLessThen1_3) {\n        var deferred = this.$q.defer();\n        // no need for parent - previous element is never null\n        this.$animate.enter(newElement, null, previousElement, function () {\n          return deferred.resolve();\n        });\n\n        return [deferred.promise];\n      }\n\n      // no need for parent - previous element is never null\n      return [this.$animate.enter(newElement, null, previousElement)];\n    }\n  }, {\n    key: 'removeElementAnimated',\n    value: function removeElementAnimated(wrapper) {\n      if (!this.$animate) {\n        return this.removeElement(wrapper);\n      }\n\n      if (this.isAngularVersionLessThen1_3) {\n        var deferred = this.$q.defer();\n        this.$animate.leave(wrapper.element, function () {\n          wrapper.scope.$destroy();\n          return deferred.resolve();\n        });\n\n        return [deferred.promise];\n      }\n\n      return [this.$animate.leave(wrapper.element).then(function () {\n        return wrapper.scope.$destroy();\n      })];\n    }\n  }]);\n\n  return ElementRoutines;\n}();\n\nexports.default = ElementRoutines;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = ScrollBuffer;\nfunction ScrollBuffer(elementRoutines, bufferSize, startIndex) {\n  var buffer = Object.create(Array.prototype);\n\n  angular.extend(buffer, {\n    size: bufferSize,\n\n    reset: function reset(startIndex) {\n      buffer.remove(0, buffer.length);\n      buffer.eof = false;\n      buffer.bof = false;\n      buffer.first = startIndex;\n      buffer.next = startIndex;\n      buffer.minIndex = startIndex;\n      buffer.maxIndex = startIndex;\n      buffer.minIndexUser = null;\n      buffer.maxIndexUser = null;\n    },\n    append: function append(items) {\n      items.forEach(function (item) {\n        ++buffer.next;\n        buffer.insert('append', item);\n      });\n      buffer.maxIndex = buffer.eof ? buffer.next - 1 : Math.max(buffer.next - 1, buffer.maxIndex);\n    },\n    prepend: function prepend(items) {\n      items.reverse().forEach(function (item) {\n        --buffer.first;\n        buffer.insert('prepend', item);\n      });\n      buffer.minIndex = buffer.bof ? buffer.minIndex = buffer.first : Math.min(buffer.first, buffer.minIndex);\n    },\n\n\n    /**\r\n     * inserts wrapped element in the buffer\r\n     * the first argument is either operation keyword (see below) or a number for operation 'insert'\r\n     * for insert the number is the index for the buffer element the new one have to be inserted after\r\n     * operations: 'append', 'prepend', 'insert', 'remove', 'update', 'none'\r\n     */\n    insert: function insert(operation, item, isTop) {\n      var wrapper = {\n        item: item\n      };\n\n      if (operation % 1 === 0) {\n        // it is an insert\n        wrapper.op = 'insert';\n        buffer.splice(operation, 0, wrapper);\n        if (isTop) {\n          buffer.first--;\n        } else {\n          buffer.next++;\n        }\n      } else {\n        wrapper.op = operation;\n        switch (operation) {\n          case 'append':\n            buffer.push(wrapper);\n            break;\n          case 'prepend':\n            buffer.unshift(wrapper);\n            break;\n        }\n      }\n    },\n\n\n    // removes elements from buffer\n    remove: function remove(arg1, arg2) {\n      if (angular.isNumber(arg1)) {\n        // removes items from arg1 (including) through arg2 (excluding)\n        for (var i = arg1; i < arg2; i++) {\n          elementRoutines.removeElement(buffer[i]);\n        }\n        return buffer.splice(arg1, arg2 - arg1);\n      }\n      // removes single item(wrapper) from the buffer\n      buffer.splice(buffer.indexOf(arg1), 1);\n      if (arg1._op === 'isTop' && buffer.first === this.getAbsMinIndex()) {\n        this.incrementMinIndex();\n      } else {\n        this.decrementMaxIndex();\n      }\n      if (arg1._op === 'isTop') {\n        buffer.first++;\n      } else {\n        buffer.next--;\n      }\n      if (!buffer.length) {\n        buffer.first = 1;\n        buffer.next = 1;\n      }\n\n      return elementRoutines.removeElementAnimated(arg1);\n    },\n    incrementMinIndex: function incrementMinIndex() {\n      if (buffer.minIndexUser !== null) {\n        if (buffer.minIndex > buffer.minIndexUser) {\n          buffer.minIndexUser++;\n          return;\n        }\n        if (buffer.minIndex === buffer.minIndexUser) {\n          buffer.minIndexUser++;\n        }\n      }\n      buffer.minIndex++;\n    },\n    decrementMaxIndex: function decrementMaxIndex() {\n      if (buffer.maxIndexUser !== null && buffer.maxIndex <= buffer.maxIndexUser) {\n        buffer.maxIndexUser--;\n      }\n      buffer.maxIndex--;\n    },\n    getAbsMinIndex: function getAbsMinIndex() {\n      if (buffer.minIndexUser !== null) {\n        return Math.min(buffer.minIndexUser, buffer.minIndex);\n      }\n      return buffer.minIndex;\n    },\n    getAbsMaxIndex: function getAbsMaxIndex() {\n      if (buffer.maxIndexUser !== null) {\n        return Math.max(buffer.maxIndexUser, buffer.maxIndex);\n      }\n      return buffer.maxIndex;\n    },\n    effectiveHeight: function effectiveHeight(elements) {\n      if (!elements.length) {\n        return 0;\n      }\n      var top = Number.MAX_VALUE;\n      var bottom = Number.NEGATIVE_INFINITY;\n      elements.forEach(function (wrapper) {\n        if (wrapper.element[0].offsetParent) {\n          // element style is not display:none\n          top = Math.min(top, wrapper.element.offset().top);\n          bottom = Math.max(bottom, wrapper.element.offset().top + wrapper.element.outerHeight(true));\n        }\n      });\n      return Math.max(0, bottom - top);\n    }\n  });\n\n  buffer.reset(startIndex);\n\n  return buffer;\n}\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Viewport;\n\nvar _padding = __webpack_require__(5);\n\nvar _padding2 = _interopRequireDefault(_padding);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction Viewport(elementRoutines, buffer, element, viewportController, $rootScope, padding) {\n  var topPadding = null;\n  var bottomPadding = null;\n  var viewport = viewportController && viewportController.viewport ? viewportController.viewport : angular.element(window);\n  var container = viewportController && viewportController.container ? viewportController.container : undefined;\n  var scope = viewportController && viewportController.scope ? viewportController.scope : $rootScope;\n\n  viewport.css({\n    'overflow-anchor': 'none',\n    'overflow-y': 'auto',\n    'display': 'block'\n  });\n\n  viewport.scrollTopOriginal = viewport.scrollTopOriginal || viewport.scrollTop;\n  viewport.scrollTopBeforeSet = null;\n  viewport.scrollTopValue = null;\n\n  function bufferPadding() {\n    return viewport.outerHeight() * padding; // some extra space to initiate preload\n  }\n\n  angular.extend(viewport, {\n    getScope: function getScope() {\n      return scope;\n    },\n    scrollTop: function scrollTop() {\n      if (typeof arguments[0] !== 'undefined') {\n        viewport.scrollTopBeforeSet = viewport.scrollTop();\n        viewport.scrollTopValue = arguments[0];\n      }\n      return viewport.scrollTopOriginal.apply(viewport, arguments);\n    },\n    createPaddingElements: function createPaddingElements(template) {\n      topPadding = new _padding2.default(template);\n      bottomPadding = new _padding2.default(template);\n      element.before(topPadding.element);\n      element.after(bottomPadding.element);\n      topPadding.height(0);\n      bottomPadding.height(0);\n    },\n    applyContainerStyle: function applyContainerStyle() {\n      if (!container) {\n        return true;\n      }\n      if (container !== viewport) {\n        viewport.css('height', window.getComputedStyle(container[0]).height);\n      }\n      return viewport.height() > 0;\n    },\n    bottomDataPos: function bottomDataPos() {\n      var scrollHeight = viewport[0].scrollHeight;\n      scrollHeight = scrollHeight != null ? scrollHeight : viewport[0].document.documentElement.scrollHeight;\n      return scrollHeight - bottomPadding.height();\n    },\n    topDataPos: function topDataPos() {\n      return topPadding.height();\n    },\n    bottomVisiblePos: function bottomVisiblePos() {\n      return viewport.scrollTop() + viewport.outerHeight();\n    },\n    topVisiblePos: function topVisiblePos() {\n      return viewport.scrollTop();\n    },\n    insertElement: function insertElement(e, sibling) {\n      return elementRoutines.insertElement(e, sibling || topPadding.element);\n    },\n    insertElementAnimated: function insertElementAnimated(e, sibling) {\n      return elementRoutines.insertElementAnimated(e, sibling || topPadding.element);\n    },\n    shouldLoadBottom: function shouldLoadBottom() {\n      return !buffer.eof && viewport.bottomDataPos() < viewport.bottomVisiblePos() + bufferPadding();\n    },\n    clipBottom: function clipBottom() {\n      // clip the invisible items off the bottom\n      var overage = 0;\n      var overageHeight = 0;\n      var itemHeight = 0;\n      var emptySpaceHeight = viewport.bottomDataPos() - viewport.bottomVisiblePos() - bufferPadding();\n\n      for (var i = buffer.length - 1; i >= 0; i--) {\n        itemHeight = buffer[i].element.outerHeight(true);\n        if (overageHeight + itemHeight > emptySpaceHeight) {\n          break;\n        }\n        bottomPadding.cache.add(buffer[i]);\n        overageHeight += itemHeight;\n        overage++;\n      }\n\n      if (overage > 0) {\n        buffer.eof = false;\n        buffer.remove(buffer.length - overage, buffer.length);\n        buffer.next -= overage;\n        viewport.adjustPaddings();\n      }\n    },\n    shouldLoadTop: function shouldLoadTop() {\n      return !buffer.bof && !viewport.scrollTopSetFailed && viewport.topDataPos() > viewport.topVisiblePos() - bufferPadding();\n    },\n    clipTop: function clipTop() {\n      // clip the invisible items off the top\n      var overage = 0;\n      var overageHeight = 0;\n      var itemHeight = 0;\n      var emptySpaceHeight = viewport.topVisiblePos() - viewport.topDataPos() - bufferPadding();\n\n      for (var i = 0; i < buffer.length; i++) {\n        itemHeight = buffer[i].element.outerHeight(true);\n        if (overageHeight + itemHeight > emptySpaceHeight) {\n          break;\n        }\n        topPadding.cache.add(buffer[i]);\n        overageHeight += itemHeight;\n        overage++;\n      }\n\n      if (overage > 0) {\n        // we need to adjust top padding element before items are removed from top\n        // to avoid strange behaviour of scroll bar during remove top items when we are at the very bottom\n        topPadding.height(topPadding.height() + overageHeight);\n        buffer.bof = false;\n        buffer.remove(0, overage);\n        buffer.first += overage;\n      }\n    },\n    adjustPaddings: function adjustPaddings() {\n      if (!buffer.length) {\n        return;\n      }\n\n      // precise heights calculation based on items that are in buffer or that were in buffer once\n      var visibleItemsHeight = buffer.reduce(function (summ, item) {\n        return summ + item.element.outerHeight(true);\n      }, 0);\n\n      var topPaddingHeight = 0,\n          topCount = 0;\n      topPadding.cache.forEach(function (item) {\n        if (item.index < buffer.first) {\n          topPaddingHeight += item.height;\n          topCount++;\n        }\n      });\n\n      var bottomPaddingHeight = 0,\n          bottomCount = 0;\n      bottomPadding.cache.forEach(function (item) {\n        if (item.index >= buffer.next) {\n          bottomPaddingHeight += item.height;\n          bottomCount++;\n        }\n      });\n\n      var totalHeight = visibleItemsHeight + topPaddingHeight + bottomPaddingHeight;\n      var averageItemHeight = totalHeight / (topCount + bottomCount + buffer.length);\n\n      // average heights calculation, items that have never been reached\n      var adjustTopPadding = buffer.minIndexUser !== null && buffer.minIndex > buffer.minIndexUser;\n      var adjustBottomPadding = buffer.maxIndexUser !== null && buffer.maxIndex < buffer.maxIndexUser;\n      var topPaddingHeightAdd = adjustTopPadding ? (buffer.minIndex - buffer.minIndexUser) * averageItemHeight : 0;\n      var bottomPaddingHeightAdd = adjustBottomPadding ? (buffer.maxIndexUser - buffer.maxIndex) * averageItemHeight : 0;\n\n      // paddings combine adjustment\n      topPadding.height(topPaddingHeight + topPaddingHeightAdd);\n      bottomPadding.height(bottomPaddingHeight + bottomPaddingHeightAdd);\n    },\n    onAfterMinIndexSet: function onAfterMinIndexSet(topPaddingHeightOld) {\n      // additional scrollTop adjustment in case of datasource.minIndex external set\n      if (buffer.minIndexUser !== null && buffer.minIndex > buffer.minIndexUser) {\n        var diff = topPadding.height() - topPaddingHeightOld;\n        viewport.scrollTop(viewport.scrollTop() + diff);\n        while ((diff -= viewport.scrollTop()) > 0) {\n          bottomPadding.height(bottomPadding.height() + diff);\n          viewport.scrollTop(viewport.scrollTop() + diff);\n        }\n      }\n    },\n    onAfterPrepend: function onAfterPrepend(updates) {\n      if (!updates.prepended.length) return;\n      var height = buffer.effectiveHeight(updates.prepended);\n      var paddingHeight = topPadding.height() - height;\n      if (paddingHeight >= 0) {\n        topPadding.height(paddingHeight);\n      } else {\n        topPadding.height(0);\n        viewport.scrollTopAdjust = paddingHeight;\n        viewport.scrollTop(viewport.scrollTop() - paddingHeight);\n      }\n    },\n    resetTopPadding: function resetTopPadding() {\n      topPadding.height(0);\n      topPadding.cache.clear();\n    },\n    resetBottomPadding: function resetBottomPadding() {\n      bottomPadding.height(0);\n      bottomPadding.cache.clear();\n    },\n    removeCacheItem: function removeCacheItem(item, isTop) {\n      topPadding.cache.remove(item, isTop);\n      bottomPadding.cache.remove(item, isTop);\n    },\n    removeItem: function removeItem(item) {\n      this.removeCacheItem(item);\n      return buffer.remove(item);\n    }\n  });\n\n  return viewport;\n}\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Can't just extend the Array, due to Babel does not support built-in classes extending\n// This solution was taken from https://stackoverflow.com/questions/46897414/es6-class-extends-array-workaround-for-es5-babel-transpile\nvar CacheProto = function () {\n  function CacheProto() {\n    _classCallCheck(this, CacheProto);\n  }\n\n  _createClass(CacheProto, [{\n    key: 'add',\n    value: function add(item) {\n      for (var i = this.length - 1; i >= 0; i--) {\n        if (this[i].index === item.scope.$index) {\n          this[i].height = item.element.outerHeight();\n          return;\n        }\n      }\n      this.push({\n        index: item.scope.$index,\n        height: item.element.outerHeight()\n      });\n      this.sort(function (a, b) {\n        return a.index < b.index ? -1 : a.index > b.index ? 1 : 0;\n      });\n    }\n  }, {\n    key: 'remove',\n    value: function remove(argument, _isTop) {\n      var index = argument % 1 === 0 ? argument : argument.scope.$index;\n      var isTop = argument % 1 === 0 ? _isTop : argument._op === 'isTop';\n      for (var i = this.length - 1; i >= 0; i--) {\n        if (this[i].index === index) {\n          this.splice(i, 1);\n          break;\n        }\n      }\n      if (!isTop) {\n        for (var _i = this.length - 1; _i >= 0; _i--) {\n          if (this[_i].index > index) {\n            this[_i].index--;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'clear',\n    value: function clear() {\n      this.length = 0;\n    }\n  }]);\n\n  return CacheProto;\n}();\n\nfunction Cache() {\n  var instance = [];\n  instance.push.apply(instance, arguments);\n  Object.setPrototypeOf(instance, Cache.prototype);\n  return instance;\n}\nCache.prototype = Object.create(Array.prototype);\nObject.getOwnPropertyNames(CacheProto.prototype).forEach(function (methodName) {\n  return Cache.prototype[methodName] = CacheProto.prototype[methodName];\n});\n\nfunction generateElement(template) {\n  if (template.nodeType !== Node.ELEMENT_NODE) {\n    throw new Error('ui-scroll directive requires an Element node for templating the view');\n  }\n  var element = void 0;\n  switch (template.tagName.toLowerCase()) {\n    case 'dl':\n      throw new Error('ui-scroll directive does not support <' + template.tagName + '> as a repeating tag: ' + template.outerHTML);\n    case 'tr':\n      var table = angular.element('<table><tr><td><div></div></td></tr></table>');\n      element = table.find('tr');\n      break;\n    case 'li':\n      element = angular.element('<li></li>');\n      break;\n    default:\n      element = angular.element('<div></div>');\n  }\n  return element;\n}\n\nvar Padding = function () {\n  function Padding(template) {\n    _classCallCheck(this, Padding);\n\n    this.element = generateElement(template);\n    this.cache = new Cache();\n  }\n\n  _createClass(Padding, [{\n    key: 'height',\n    value: function height() {\n      return this.element.height.apply(this.element, arguments);\n    }\n  }]);\n\n  return Padding;\n}();\n\nexports.default = Padding;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Adapter = function () {\n  function Adapter($scope, $parse, $attr, viewport, buffer, doAdjust, reload) {\n    _classCallCheck(this, Adapter);\n\n    this.$parse = $parse;\n    this.$attr = $attr;\n    this.viewport = viewport;\n    this.buffer = buffer;\n\n    this.doAdjust = doAdjust;\n    this.reload = reload;\n\n    this.isLoading = false;\n    this.disabled = false;\n\n    var viewportScope = viewport.getScope();\n    this.startScope = viewportScope.$parent ? viewportScope : $scope;\n\n    this.publicContext = {};\n    this.assignAdapter($attr.adapter);\n    this.generatePublicContext();\n  }\n\n  _createClass(Adapter, [{\n    key: 'assignAdapter',\n    value: function assignAdapter(adapterAttr) {\n      if (!adapterAttr || !(adapterAttr = adapterAttr.replace(/^\\s+|\\s+$/gm, ''))) {\n        return;\n      }\n      var adapterOnScope = void 0;\n\n      try {\n        this.$parse(adapterAttr).assign(this.startScope, {});\n        adapterOnScope = this.$parse(adapterAttr)(this.startScope);\n      } catch (error) {\n        error.message = 'Angular ui-scroll Adapter assignment exception.\\n' + ('Can\\'t parse \"' + adapterAttr + '\" expression.\\n') + error.message;\n        throw error;\n      }\n\n      angular.extend(adapterOnScope, this.publicContext);\n      this.publicContext = adapterOnScope;\n    }\n  }, {\n    key: 'generatePublicContext',\n    value: function generatePublicContext() {\n      var _this = this;\n\n      // these methods will be accessible out of ui-scroll via user defined adapter\n      var publicMethods = ['reload', 'applyUpdates', 'append', 'prepend', 'isBOF', 'isEOF', 'isEmpty', 'resetScrollTopCorrection'];\n      for (var i = publicMethods.length - 1; i >= 0; i--) {\n        this.publicContext[publicMethods[i]] = this[publicMethods[i]].bind(this);\n      }\n\n      // these read-only props will be accessible out of ui-scroll via user defined adapter\n      var publicProps = ['isLoading', 'topVisible', 'topVisibleElement', 'topVisibleScope', 'bottomVisible', 'bottomVisibleElement', 'bottomVisibleScope'];\n\n      var _loop = function _loop(_i) {\n        var property = void 0,\n            attr = _this.$attr[publicProps[_i]];\n        Object.defineProperty(_this, publicProps[_i], {\n          get: function get() {\n            return property;\n          },\n          set: function set(value) {\n            property = value;\n            _this.publicContext[publicProps[_i]] = value;\n            if (attr) {\n              _this.$parse(attr).assign(_this.startScope, value);\n            }\n          }\n        });\n      };\n\n      for (var _i = publicProps.length - 1; _i >= 0; _i--) {\n        _loop(_i);\n      }\n\n      // non-read-only public property\n      Object.defineProperty(this.publicContext, 'disabled', {\n        get: function get() {\n          return _this.disabled;\n        },\n        set: function set(value) {\n          return !(_this.disabled = value) ? _this.doAdjust() : null;\n        }\n      });\n    }\n  }, {\n    key: 'loading',\n    value: function loading(value) {\n      this.isLoading = value;\n    }\n  }, {\n    key: 'isBOF',\n    value: function isBOF() {\n      return this.buffer.bof;\n    }\n  }, {\n    key: 'isEOF',\n    value: function isEOF() {\n      return this.buffer.eof;\n    }\n  }, {\n    key: 'isEmpty',\n    value: function isEmpty() {\n      return !this.buffer.length;\n    }\n  }, {\n    key: 'resetScrollTopCorrection',\n    value: function resetScrollTopCorrection() {\n      // is needed to scroll at negative area programmatically (e.g. tests)\n      this.viewport.scrollTopValue = null;\n    }\n  }, {\n    key: 'append',\n    value: function append(newItems) {\n      this.buffer.append(newItems);\n      this.doAdjust();\n      this.viewport.clipTop();\n      this.viewport.clipBottom();\n    }\n  }, {\n    key: 'prepend',\n    value: function prepend(newItems) {\n      this.buffer.prepend(newItems);\n      this.doAdjust();\n      this.viewport.clipTop();\n      this.viewport.clipBottom();\n    }\n  }, {\n    key: 'applyUpdates',\n    value: function applyUpdates(arg1, arg2) {\n      if (typeof arg1 === 'function') {\n        this.applyUpdatesFunc(arg1);\n      } else {\n        this.applyUpdatesIndex(arg1, arg2);\n      }\n      this.doAdjust();\n    }\n  }, {\n    key: 'applyUpdatesFunc',\n    value: function applyUpdatesFunc(cb) {\n      var _this2 = this;\n\n      this.buffer.slice(0).forEach(function (wrapper) {\n        // we need to do it on the buffer clone, because buffer content\n        // may change as we iterate through\n        _this2.applyUpdate(wrapper, cb(wrapper.item, wrapper.scope, wrapper.element));\n      });\n    }\n  }, {\n    key: 'applyUpdatesIndex',\n    value: function applyUpdatesIndex(index, newItems) {\n      if (index % 1 !== 0) {\n        throw new Error('applyUpdates - ' + index + ' is not a valid index (should be an integer)');\n      }\n      var _index = index - this.buffer.first;\n\n      // apply updates only within buffer\n      if (_index >= 0 && _index < this.buffer.length) {\n        this.applyUpdate(this.buffer[_index], newItems);\n      }\n      // out-of-buffer case: deletion may affect Paddings\n      else if (index >= this.buffer.getAbsMinIndex() && index <= this.buffer.getAbsMaxIndex()) {\n          if (angular.isArray(newItems) && !newItems.length) {\n            this.viewport.removeCacheItem(index, index === this.buffer.minIndex);\n            if (index === this.buffer.getAbsMinIndex()) {\n              this.buffer.incrementMinIndex();\n            } else {\n              this.buffer.decrementMaxIndex();\n            }\n          }\n        }\n    }\n  }, {\n    key: 'applyUpdate',\n    value: function applyUpdate(wrapper, newItems) {\n      var _this3 = this;\n\n      if (!angular.isArray(newItems)) {\n        return;\n      }\n      var position = this.buffer.indexOf(wrapper);\n      if (!newItems.reverse().some(function (newItem) {\n        return newItem === wrapper.item;\n      })) {\n        wrapper.op = 'remove';\n        if (position === 0 && !newItems.length) {\n          wrapper._op = 'isTop'; // to catch \"first\" edge case on remove\n        }\n      }\n      newItems.forEach(function (newItem) {\n        if (newItem === wrapper.item) {\n          position--;\n        } else {\n          // 3 parameter (isTop) is to catch \"first\" edge case on insert\n          _this3.buffer.insert(position + 1, newItem, position === -1);\n        }\n      });\n    }\n  }, {\n    key: 'calculateProperties',\n    value: function calculateProperties() {\n      var rowTop = null,\n          topHeight = 0;\n      var topDone = false,\n          bottomDone = false;\n      var length = this.buffer.length;\n\n      for (var i = 0; i < length; i++) {\n        var item = this.buffer[i];\n        var itemTop = item.element.offset().top;\n\n        if (rowTop !== itemTop) {\n          // a new row condition\n          var itemHeight = item.element.outerHeight(true);\n          var top = this.viewport.topDataPos() + topHeight + itemHeight;\n\n          if (!topDone && top > this.viewport.topVisiblePos()) {\n            topDone = true;\n            this['topVisible'] = item.item;\n            this['topVisibleElement'] = item.element;\n            this['topVisibleScope'] = item.scope;\n          }\n          if (!bottomDone && (top >= this.viewport.bottomVisiblePos() || i === length - 1 && this.isEOF())) {\n            bottomDone = true;\n            this['bottomVisible'] = item.item;\n            this['bottomVisibleElement'] = item.element;\n            this['bottomVisibleScope'] = item.scope;\n          }\n          topHeight += itemHeight;\n        }\n        rowTop = itemTop;\n\n        if (topDone && bottomDone) {\n          break;\n        }\n      }\n    }\n  }]);\n\n  return Adapter;\n}();\n\nexports.default = Adapter;\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// ui-scroll.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2386088bf7ce5bf5d4af","import JQLiteExtras from './modules/jqLiteExtras';\nimport ElementRoutines from './modules/elementRoutines.js';\nimport ScrollBuffer from './modules/buffer.js';\nimport Viewport from './modules/viewport.js';\nimport Adapter from './modules/adapter.js';\n\nangular.module('ui.scroll', [])\n\n  .constant('JQLiteExtras', JQLiteExtras)\n  .run(['JQLiteExtras', (JQLiteExtras) => {\n    !window.jQuery ? (new JQLiteExtras()).registerFor(angular.element) : null;\n    ElementRoutines.addCSSRules();\n  }])\n\n  .directive('uiScrollViewport', function () {\n    return {\n      restrict: 'A',\n      controller: [\n        '$scope',\n        '$element',\n        function (scope, element) {\n          this.container = element;\n          this.viewport = element;\n          this.scope = scope;\n\n          angular.forEach(element.children(), child => {\n            if (child.tagName.toLowerCase() === 'tbody') {\n              this.viewport = angular.element(child);\n            }\n          });\n\n          return this;\n        }\n      ]\n    };\n  })\n\n  .directive('uiScroll', [\n    '$log',\n    '$injector',\n    '$rootScope',\n    '$timeout',\n    '$interval',\n    '$q',\n    '$parse',\n    function (console, $injector, $rootScope, $timeout, $interval, $q, $parse) {\n\n      return {\n        require: ['?^uiScrollViewport'],\n        restrict: 'A',\n        transclude: 'element',\n        priority: 1000,\n        terminal: true,\n        link: link\n      };\n\n      function link($scope, element, $attr, controllers, linker) {\n        const match = $attr.uiScroll.match(/^\\s*(\\w+)\\s+in\\s+([(\\w|\\$)\\.]+)\\s*$/);\n        if (!match) {\n          throw new Error('Expected uiScroll in form of \\'_item_ in _datasource_\\' but got \\'' + $attr.uiScroll + '\\'');\n        }\n\n        function parseNumericAttr(value, defaultValue) {\n          const result = $parse(value)($scope);\n          return isNaN(result) ? defaultValue : result;\n        }\n\n        const BUFFER_MIN = 3;\n        const BUFFER_DEFAULT = 10;\n        const PADDING_MIN = 0.01;\n        const PADDING_DEFAULT = 0.5;\n        const MAX_VIEWPORT_DELAY = 500;\n        const VIEWPORT_POLLING_INTERVAL = 50;\n\n        let datasource = null;\n        const itemName = match[1];\n        const datasourceName = match[2];\n        const viewportController = controllers[0];\n        const bufferSize = Math.max(BUFFER_MIN, parseNumericAttr($attr.bufferSize, BUFFER_DEFAULT));\n        const padding = Math.max(PADDING_MIN, parseNumericAttr($attr.padding, PADDING_DEFAULT));\n        let startIndex = parseNumericAttr($attr.startIndex, 1);\n        let ridActual = 0; // current data revision id\n        let pending = [];\n\n        const elementRoutines = new ElementRoutines($injector, $q);\n        const buffer = new ScrollBuffer(elementRoutines, bufferSize, startIndex);\n        const viewport = new Viewport(elementRoutines, buffer, element, viewportController, $rootScope, padding);\n        const adapter = new Adapter($scope, $parse, $attr, viewport, buffer, doAdjust, reload);\n\n        if (viewportController) {\n          viewportController.adapter = adapter;\n        }\n\n        const isDatasourceValid = () =>\n          Object.prototype.toString.call(datasource) === '[object Object]' && typeof datasource.get === 'function';\n\n        datasource = $parse(datasourceName)($scope); // try to get datasource on scope\n        if (!isDatasourceValid()) {\n          datasource = $injector.get(datasourceName); // try to inject datasource as service\n          if (!isDatasourceValid()) {\n            throw new Error(datasourceName + ' is not a valid datasource');\n          }\n        }\n\n        let onRenderHandlers = [];\n        function onRenderHandlersRunner() {\n          onRenderHandlers.forEach(handler => handler.run());\n          onRenderHandlers = [];\n        }\n        function persistDatasourceIndex(datasource, propName) {\n          let getter;\n          // need to postpone min/maxIndexUser processing if the view is empty\n          if(angular.isNumber(datasource[propName])) {\n            getter = datasource[propName];\n            if(angular.isNumber(getter)) {\n              onRenderHandlers = onRenderHandlers.filter(handler => handler.id !== propName);\n              onRenderHandlers.push({\n                id: propName,\n                run: () => datasource[propName] = getter\n              });\n            }\n          }\n        }\n\n        function defineDatasourceIndex(datasource, propName, propUserName) {\n          const descriptor = Object.getOwnPropertyDescriptor(datasource, propName);\n          if (descriptor && (descriptor.set || descriptor.get)) {\n            return;\n          }\n          let getter;\n          persistDatasourceIndex(datasource, propName);\n          Object.defineProperty(datasource, propName, {\n            set: (value) => {\n              getter = value;\n              if(pending.length && !buffer.length) {\n                persistDatasourceIndex(datasource, propName);\n                return;\n              }\n              buffer[propUserName] = value;\n              const topPaddingHeightOld = viewport.topDataPos();\n              viewport.adjustPaddings();\n              if (propName === 'minIndex') {\n                viewport.onAfterMinIndexSet(topPaddingHeightOld);\n              }\n            },\n            get: () => getter\n          });\n        }\n\n        defineDatasourceIndex(datasource, 'minIndex', 'minIndexUser');\n        defineDatasourceIndex(datasource, 'maxIndex', 'maxIndexUser');\n\n        const fetchNext = (datasource.get.length !== 2) ?\n          (success) => datasource.get(buffer.next, bufferSize, success) :\n          (success) => {\n            datasource.get({\n              index: buffer.next,\n              append: buffer.length ? buffer[buffer.length - 1].item : void 0,\n              count: bufferSize\n            }, success);\n          };\n\n        const fetchPrevious = (datasource.get.length !== 2) ?\n          (success) => datasource.get(buffer.first - bufferSize, bufferSize, success) :\n          (success) => {\n            datasource.get({\n              index: buffer.first - bufferSize,\n              prepend: buffer.length ? buffer[0].item : void 0,\n              count: bufferSize\n            }, success);\n          };\n\n        const initialize = () => {\n          let tryCount = 0;\n          if(!viewport.applyContainerStyle()) {\n            const timer = $interval(() => {\n              tryCount++;\n              if(viewport.applyContainerStyle()) {\n                $interval.cancel(timer);\n                doAdjust();\n              }\n              if(tryCount * VIEWPORT_POLLING_INTERVAL >= MAX_VIEWPORT_DELAY) {\n                $interval.cancel(timer);\n                throw Error(`ui-scroll directive requires a viewport with non-zero height in ${MAX_VIEWPORT_DELAY}ms`);\n              }\n            }, VIEWPORT_POLLING_INTERVAL);\n          }\n          else {\n            doAdjust();\n          }\n        };\n\n        /**\n         * Build padding elements\n         *\n         * Calling linker is the only way I found to get access to the tag name of the template\n         * to prevent the directive scope from pollution a new scope is created and destroyed\n         * right after the builder creation is completed\n         */\n        linker((clone, scope) => {\n          viewport.createPaddingElements(clone[0]);\n          // we do not include the clone in the DOM. It means that the nested directives will not\n          // be able to reach the parent directives, but in this case it is intentional because we\n          // created the clone to access the template tag name\n          scope.$destroy();\n          clone.remove();\n        });\n\n        $scope.$on('$destroy', () => {\n          unbindEvents();\n          viewport.unbind('mousewheel', wheelHandler);\n        });\n\n        viewport.bind('mousewheel', wheelHandler);\n\n        initialize();\n\n        /* Private function definitions */\n\n        function isInvalid(rid) {\n          return (rid && rid !== ridActual) || $scope.$$destroyed;\n        }\n\n        function bindEvents() {\n          viewport.bind('resize', resizeAndScrollHandler);\n          viewport.bind('scroll', resizeAndScrollHandler);\n        }\n\n        function unbindEvents() {\n          viewport.unbind('resize', resizeAndScrollHandler);\n          viewport.unbind('scroll', resizeAndScrollHandler);\n        }\n\n        function reload() {\n          viewport.resetTopPadding();\n          viewport.resetBottomPadding();\n          if (arguments.length) {\n            startIndex = arguments[0];\n          }\n          buffer.reset(startIndex);\n          persistDatasourceIndex(datasource, 'minIndex');\n          persistDatasourceIndex(datasource, 'maxIndex');\n          doAdjust();\n        }\n\n        function isElementVisible(wrapper) {\n          return wrapper.element.height() && wrapper.element[0].offsetParent;\n        }\n\n        function visibilityWatcher(wrapper) {\n          if (isElementVisible(wrapper)) {\n            buffer.forEach((item) => {\n              if (typeof item.unregisterVisibilityWatcher === 'function') {\n                item.unregisterVisibilityWatcher();\n                delete item.unregisterVisibilityWatcher;\n              }\n            });\n            if (!pending.length) {\n              $timeout(() => doAdjust());\n            }\n          }\n        }\n\n        function insertWrapperContent(wrapper, insertAfter) {\n          createElement(wrapper, insertAfter, viewport.insertElement);\n          if (!isElementVisible(wrapper)) {\n            wrapper.unregisterVisibilityWatcher = wrapper.scope.$watch(() => visibilityWatcher(wrapper));\n          }\n          elementRoutines.hideElement(wrapper); // hide inserted elements before data binding\n        }\n\n        function createElement(wrapper, insertAfter, insertElement) {\n          let promises = null;\n          const sibling = (insertAfter > 0) ? buffer[insertAfter - 1].element : undefined;\n          linker((clone, scope) => {\n            promises = insertElement(clone, sibling);\n            wrapper.element = clone;\n            wrapper.scope = scope;\n            scope[itemName] = wrapper.item;\n          });\n          // ui-scroll-grid apply\n          if (adapter.transform) {\n            const tdInitializer = wrapper.scope.uiScrollTdInitializer;\n            if (tdInitializer && tdInitializer.linking) {\n              adapter.transform(wrapper.scope, wrapper.element);\n            } else {\n              wrapper.scope.uiScrollTdInitializer = {\n                onLink: () => adapter.transform(wrapper.scope, wrapper.element),\n                scope: wrapper.scope\n              };\n            }\n          }\n          return promises;\n        }\n\n        function updateDOM() {\n          let promises = [];\n          const toBePrepended = [];\n          const toBeRemoved = [];\n          const inserted = [];\n\n          buffer.forEach((wrapper, i) => {\n            switch (wrapper.op) {\n              case 'prepend':\n                toBePrepended.unshift(wrapper);\n                break;\n              case 'append':\n                insertWrapperContent(wrapper, i);\n                wrapper.op = 'none';\n                inserted.push(wrapper);\n                break;\n              case 'insert':\n                promises = promises.concat(createElement(wrapper, i, viewport.insertElementAnimated));\n                wrapper.op = 'none';\n                inserted.push(wrapper);\n                break;\n              case 'remove':\n                toBeRemoved.push(wrapper);\n            }\n          });\n\n          toBeRemoved.forEach((wrapper) => promises = promises.concat(viewport.removeItem(wrapper)));\n\n          if (toBePrepended.length)\n            toBePrepended.forEach((wrapper) => {\n              insertWrapperContent(wrapper);\n              wrapper.op = 'none';\n            });\n\n          buffer.forEach((item, i) => item.scope.$index = buffer.first + i);\n\n          return {\n            prepended: toBePrepended,\n            removed: toBeRemoved,\n            inserted: inserted,\n            animated: promises\n          };\n\n        }\n\n        function updatePaddings(rid, updates) {\n          // schedule another doAdjust after animation completion\n          if (updates.animated.length) {\n            $q.all(updates.animated).then(() => {\n              viewport.adjustPaddings();\n              doAdjust(rid);\n            });\n          } else {\n            viewport.adjustPaddings();\n          }\n        }\n\n        function enqueueFetch(rid, updates) {\n          if (viewport.shouldLoadBottom()) {\n            if (!updates || buffer.effectiveHeight(updates.inserted) > 0) {\n              // this means that at least one item appended in the last batch has height > 0\n              if (pending.push(true) === 1) {\n                adapter.loading(true);\n                fetch(rid);\n              }\n            }\n          } else if (viewport.shouldLoadTop()) {\n            if ((!updates || buffer.effectiveHeight(updates.prepended) > 0) || pending[0]) {\n              // this means that at least one item appended in the last batch has height > 0\n              // pending[0] = true means that previous fetch was appending. We need to force at least one prepend\n              // BTW there will always be at least 1 element in the pending array because bottom is fetched first\n              if (pending.push(false) === 1) {\n                adapter.loading(true);\n                fetch(rid);\n              }\n            }\n          }\n        }\n\n        function processUpdates() {\n          const updates = updateDOM();\n\n          // We need the item bindings to be processed before we can do adjustments\n          !$scope.$$phase && !$rootScope.$$phase && $scope.$digest();\n\n          updates.inserted.forEach(w => elementRoutines.showElement(w));\n          updates.prepended.forEach(w => elementRoutines.showElement(w));\n          return updates;\n        }\n\n        function doAdjust(rid) {\n          if (!rid) { // dismiss pending requests\n            pending = [];\n            rid = ++ridActual;\n          }\n\n          const updates = processUpdates();\n\n          if (isInvalid(rid)) {\n            return;\n          }\n\n          updatePaddings(rid, updates);\n          enqueueFetch(rid);\n\n          if (!pending.length) {\n            adapter.calculateProperties();\n          }\n        }\n\n        function doAdjustAfterFetch(rid) {\n          const updates = processUpdates();\n\n          viewport.onAfterPrepend(updates);\n\n          if (isInvalid(rid)) {\n            return;\n          }\n\n          updatePaddings(rid, updates);\n          onRenderHandlersRunner();\n          enqueueFetch(rid, updates);\n          pending.shift();\n\n          if (pending.length)\n            fetch(rid);\n          else {\n            adapter.loading(false);\n            bindEvents();\n            adapter.calculateProperties();\n          }\n        }\n\n        function fetch(rid) {\n          if (pending[0]) {// scrolling down\n            if (buffer.length && !viewport.shouldLoadBottom()) {\n              doAdjustAfterFetch(rid);\n            } else {\n              fetchNext((result) => {\n                if (isInvalid(rid)) {\n                  return;\n                }\n\n                if (result.length < bufferSize) {\n                  buffer.eof = true;\n                }\n\n                if (result.length > 0) {\n                  viewport.clipTop();\n                  buffer.append(result);\n                }\n\n                doAdjustAfterFetch(rid);\n              });\n            }\n          } else {  // scrolling up\n            if (buffer.length && !viewport.shouldLoadTop()) {\n              doAdjustAfterFetch(rid);\n            } else {\n              fetchPrevious((result) => {\n                if (isInvalid(rid)) {\n                  return;\n                }\n\n                if (result.length < bufferSize) {\n                  buffer.bof = true;\n                  // log 'bof is reached'\n                }\n\n                if (result.length > 0) {\n                  if (buffer.length) {\n                    viewport.clipBottom();\n                  }\n                  buffer.prepend(result);\n                }\n\n                doAdjustAfterFetch(rid);\n              });\n            }\n          }\n        }\n\n        function resizeAndScrollHandler(ev) {\n          if ($rootScope.$$phase || adapter.isLoading || adapter.disabled) {\n            return;\n          }\n\n          if (ev.type === 'scroll') {\n            // Don't process scroll event if it was triggered by us setting scrollTop.\n            if (viewport[0].scrollTop === viewport.scrollTopValue) {\n              return false;\n            }\n\n            // Check if we tried to set scrollTop and it failed. If that happens, don't prepend more items based on the stale value\n            // of scrollTop that will be used by shouldLoadTop(). Also, try to set it again.\n            viewport.scrollTopSetFailed = false;\n            if (viewport.scrollTopValue != null) {\n              const curScrollTop = viewport[0].scrollTop;\n              if (Math.abs(curScrollTop - viewport.scrollTopValue) > Math.abs(curScrollTop - viewport.scrollTopBeforeSet)) {\n                viewport.scrollTopSetFailed = true;\n                viewport.scrollTop(curScrollTop - viewport.scrollTopAdjust);\n              }\n            }\n          }\n\n          enqueueFetch(ridActual);\n\n          // we got a real scroll event, so browser is now in charge of scrollTop\n          viewport.scrollTopValue = null;\n\n          if (pending.length) {\n            unbindEvents();\n          } else {\n            adapter.calculateProperties();\n            !$scope.$$phase && $scope.$digest();\n          }\n        }\n\n        function wheelHandler(event) {\n          if (!adapter.disabled) {\n            const scrollTop = viewport[0].scrollTop;\n            const yMax = viewport[0].scrollHeight - viewport[0].clientHeight;\n\n            if ((scrollTop === 0 && !buffer.bof) || (scrollTop === yMax && !buffer.eof)) {\n              event.preventDefault();\n            }\n          }\n        }\n      }\n\n    }\n  ]);\n\n\n\n// WEBPACK FOOTER //\n// ./src/ui-scroll.js","/*!\r\n globals: angular, window\r\n List of used element methods available in JQuery but not in JQuery Lite\r\n element.before(elem)\r\n element.height()\r\n element.outerHeight(true)\r\n element.height(value) = only for Top/Bottom padding elements\r\n element.scrollTop()\r\n element.scrollTop(value)\r\n */\r\n\r\nexport default class JQLiteExtras {\r\n\r\n  registerFor(element) {\r\n    let convertToPx, css, getStyle, isWindow;\r\n    // angular implementation blows up if elem is the window\r\n    css = angular.element.prototype.css;\r\n\r\n    element.prototype.css = function (name, value) {\r\n      let self = this;\r\n      let elem = self[0];\r\n      if (!(!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style)) {\r\n        return css.call(self, name, value);\r\n      }\r\n    };\r\n\r\n    // as defined in angularjs v1.0.5\r\n    isWindow = (obj) => obj && obj.document && obj.location && obj.alert && obj.setInterval;\r\n\r\n    function scrollTo(self, direction, value) {\r\n      let elem = self[0];\r\n      let [method, prop, preserve] = {\r\n        top: [\r\n          'scrollTop',\r\n          'pageYOffset',\r\n          'scrollLeft'\r\n        ],\r\n        left: [\r\n          'scrollLeft',\r\n          'pageXOffset',\r\n          'scrollTop'\r\n        ]\r\n      }[direction];\r\n\r\n      const isValueDefined = typeof value !== 'undefined';\r\n      if (isWindow(elem)) {\r\n        if (isValueDefined) {\r\n          return elem.scrollTo(self[preserve].call(self), value);\r\n        }\r\n        return (prop in elem) ? elem[prop] : elem.document.documentElement[method];\r\n      } else {\r\n        if (isValueDefined) {\r\n          elem[method] = value;\r\n        }\r\n        return elem[method];\r\n      }\r\n    }\r\n\r\n    if (window.getComputedStyle) {\r\n      getStyle = (elem) => window.getComputedStyle(elem, null);\r\n      convertToPx = (elem, value) => parseFloat(value);\r\n    } else {\r\n      getStyle = (elem) => elem.currentStyle;\r\n      convertToPx = (elem, value) => {\r\n        let left, result, rs, rsLeft, style;\r\n        let core_pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\r\n        let rnumnonpx = new RegExp('^(' + core_pnum + ')(?!px)[a-z%]+$', 'i');\r\n\r\n        if (!rnumnonpx.test(value)) {\r\n          return parseFloat(value);\r\n        }\r\n\r\n        // ported from JQuery\r\n        style = elem.style;\r\n        left = style.left;\r\n        rs = elem.runtimeStyle;\r\n        rsLeft = rs && rs.left;\r\n        if (rs) {\r\n          rs.left = style.left;\r\n        }\r\n        // put in the new values to get a computed style out\r\n        style.left = value;\r\n        result = style.pixelLeft;\r\n        style.left = left;\r\n        if (rsLeft) {\r\n          rs.left = rsLeft;\r\n        }\r\n        return result;\r\n      };\r\n    }\r\n\r\n    function getMeasurements(elem, measure) {\r\n      let base, borderA, borderB, computedMarginA, computedMarginB, computedStyle, dirA, dirB, marginA, marginB, paddingA, paddingB;\r\n\r\n      if (isWindow(elem)) {\r\n        base = document.documentElement[{height: 'clientHeight', width: 'clientWidth'}[measure]];\r\n\r\n        return {\r\n          base: base,\r\n          padding: 0,\r\n          border: 0,\r\n          margin: 0\r\n        };\r\n      }\r\n\r\n      // Start with offset property\r\n      [\r\n        base,\r\n        dirA,\r\n        dirB\r\n      ] = {\r\n        width: [\r\n          elem.offsetWidth,\r\n          'Left',\r\n          'Right'\r\n        ],\r\n        height: [\r\n          elem.offsetHeight,\r\n          'Top',\r\n          'Bottom'\r\n        ]\r\n      }[measure];\r\n\r\n      computedStyle = getStyle(elem);\r\n      paddingA = convertToPx(elem, computedStyle['padding' + dirA]) || 0;\r\n      paddingB = convertToPx(elem, computedStyle['padding' + dirB]) || 0;\r\n      borderA = convertToPx(elem, computedStyle['border' + dirA + 'Width']) || 0;\r\n      borderB = convertToPx(elem, computedStyle['border' + dirB + 'Width']) || 0;\r\n      computedMarginA = computedStyle['margin' + dirA];\r\n      computedMarginB = computedStyle['margin' + dirB];\r\n\r\n      // I do not care for width for now, so this hack is irrelevant\r\n      // if ( !supportsPercentMargin )\r\n      // computedMarginA = hackPercentMargin( elem, computedStyle, computedMarginA )\r\n      // computedMarginB = hackPercentMargin( elem, computedStyle, computedMarginB )\r\n      marginA = convertToPx(elem, computedMarginA) || 0;\r\n      marginB = convertToPx(elem, computedMarginB) || 0;\r\n\r\n      return {\r\n        base: base,\r\n        padding: paddingA + paddingB,\r\n        border: borderA + borderB,\r\n        margin: marginA + marginB\r\n      };\r\n    }\r\n\r\n    function getWidthHeight(elem, direction, measure) {\r\n      let computedStyle, result;\r\n\r\n      let measurements = getMeasurements(elem, direction);\r\n\r\n      if (measurements.base > 0) {\r\n        return {\r\n          base: measurements.base - measurements.padding - measurements.border,\r\n          outer: measurements.base,\r\n          outerfull: measurements.base + measurements.margin\r\n        }[measure];\r\n      }\r\n\r\n      // Fall back to computed then uncomputed css if necessary\r\n      computedStyle = getStyle(elem);\r\n      result = computedStyle[direction];\r\n\r\n      if (result < 0 || result === null) {\r\n        result = elem.style[direction] || 0;\r\n      }\r\n\r\n      // Normalize \"\", auto, and prepare for extra\r\n      result = parseFloat(result) || 0;\r\n\r\n      return {\r\n        base: result - measurements.padding - measurements.border,\r\n        outer: result,\r\n        outerfull: result + measurements.padding + measurements.border + measurements.margin\r\n      }[measure];\r\n    }\r\n\r\n    // define missing methods\r\n    return angular.forEach({\r\n      before(newElem) {\r\n        var children, elem, i, j, parent, ref, self;\r\n        self = this;\r\n        elem = self[0];\r\n        parent = self.parent();\r\n        children = parent.contents();\r\n        if (children[0] === elem) {\r\n          return parent.prepend(newElem);\r\n        } else {\r\n          for (i = j = 1, ref = children.length - 1; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {\r\n            if (children[i] === elem) {\r\n              angular.element(children[i - 1]).after(newElem);\r\n              return;\r\n            }\r\n          }\r\n          throw new Error('invalid DOM structure ' + elem.outerHTML);\r\n        }\r\n      },\r\n      height (value){\r\n        var self;\r\n        self = this;\r\n        if (typeof value !== 'undefined') {\r\n          if (angular.isNumber(value)) {\r\n            value = value + 'px';\r\n          }\r\n          return css.call(self, 'height', value);\r\n        } else {\r\n          return getWidthHeight(this[0], 'height', 'base');\r\n        }\r\n      },\r\n      outerHeight(option) {\r\n        return getWidthHeight(this[0], 'height', option ? 'outerfull' : 'outer');\r\n      },\r\n      outerWidth(option) {\r\n        return getWidthHeight(this[0], 'width', option ? 'outerfull' : 'outer');\r\n      },\r\n\r\n      /*\r\n       The offset setter method is not implemented\r\n       */\r\n      offset(value) {\r\n        let docElem, win;\r\n        let self = this;\r\n        let box = {\r\n          top: 0,\r\n          left: 0\r\n        };\r\n        let elem = self[0];\r\n        let doc = elem && elem.ownerDocument;\r\n\r\n        if (arguments.length) {\r\n          if (value === undefined) {\r\n            return self;\r\n          }\r\n          // TODO: implement setter\r\n          throw new Error('offset setter method is not implemented');\r\n        }\r\n\r\n        if (!doc) {\r\n          return;\r\n        }\r\n\r\n        docElem = doc.documentElement;\r\n\r\n        // TODO: Make sure it's not a disconnected DOM node\r\n\r\n        if (elem.getBoundingClientRect != null) {\r\n          box = elem.getBoundingClientRect();\r\n        }\r\n\r\n        win = doc.defaultView || doc.parentWindow;\r\n\r\n        return {\r\n          top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),\r\n          left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)\r\n        };\r\n      },\r\n      scrollTop(value) {\r\n        return scrollTo(this, 'top', value);\r\n      },\r\n      scrollLeft(value) {\r\n        return scrollTo(this, 'left', value);\r\n      }\r\n    }, (value, key) => {\r\n      if (!element.prototype[key]) {\r\n        return element.prototype[key] = value;\r\n      }\r\n    });\r\n  }\r\n\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/modules/jqLiteExtras.js","const hideClassToken = 'ng-ui-scroll-hide';\r\n\r\nexport default class ElementRoutines {\r\n\r\n  static addCSSRules() {\r\n    const selector = '.' + hideClassToken;\r\n    const rules = 'display: none';\r\n    const sheet = document.styleSheets[0];\r\n    let index;\r\n    try {\r\n      index = sheet.cssRules.length;\r\n    } catch (err) {\r\n      index = 0;\r\n    }\r\n    if('insertRule' in sheet) {\r\n      sheet.insertRule(selector + '{' + rules + '}', index);\r\n    }\r\n    else if('addRule' in sheet) {\r\n      sheet.addRule(selector, rules, index);\r\n    }\r\n  }\r\n\r\n  constructor($injector, $q) {\r\n    this.$animate = ($injector.has && $injector.has('$animate')) ? $injector.get('$animate') : null;\r\n    this.isAngularVersionLessThen1_3 = angular.version.major === 1 && angular.version.minor < 3;\r\n    this.$q = $q;\r\n  }\r\n\r\n  hideElement(wrapper) {\r\n    wrapper.element.addClass(hideClassToken);\r\n  }\r\n\r\n  showElement(wrapper) {\r\n    wrapper.element.removeClass(hideClassToken);\r\n  }\r\n\r\n  insertElement(newElement, previousElement) {\r\n    previousElement.after(newElement);\r\n    return [];\r\n  }\r\n\r\n  removeElement(wrapper) {\r\n    wrapper.element.remove();\r\n    wrapper.scope.$destroy();\r\n    return [];\r\n  }\r\n\r\n  insertElementAnimated(newElement, previousElement) {\r\n    if (!this.$animate) {\r\n      return this.insertElement(newElement, previousElement);\r\n    }\r\n\r\n    if (this.isAngularVersionLessThen1_3) {\r\n      const deferred = this.$q.defer();\r\n      // no need for parent - previous element is never null\r\n      this.$animate.enter(newElement, null, previousElement, () => deferred.resolve());\r\n\r\n      return [deferred.promise];\r\n    }\r\n\r\n    // no need for parent - previous element is never null\r\n    return [this.$animate.enter(newElement, null, previousElement)];\r\n  }\r\n\r\n  removeElementAnimated(wrapper) {\r\n    if (!this.$animate) {\r\n      return this.removeElement(wrapper);\r\n    }\r\n\r\n    if (this.isAngularVersionLessThen1_3) {\r\n      const deferred = this.$q.defer();\r\n      this.$animate.leave(wrapper.element, () => {\r\n        wrapper.scope.$destroy();\r\n        return deferred.resolve();\r\n      });\r\n\r\n      return [deferred.promise];\r\n    }\r\n\r\n    return [(this.$animate.leave(wrapper.element)).then(() => wrapper.scope.$destroy())];\r\n  }\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/modules/elementRoutines.js","export default function ScrollBuffer(elementRoutines, bufferSize, startIndex) {\r\n  const buffer = Object.create(Array.prototype);\r\n\r\n  angular.extend(buffer, {\r\n    size: bufferSize,\r\n\r\n    reset(startIndex) {\r\n      buffer.remove(0, buffer.length);\r\n      buffer.eof = false;\r\n      buffer.bof = false;\r\n      buffer.first = startIndex;\r\n      buffer.next = startIndex;\r\n      buffer.minIndex = startIndex;\r\n      buffer.maxIndex = startIndex;\r\n      buffer.minIndexUser = null;\r\n      buffer.maxIndexUser = null;\r\n    },\r\n\r\n    append(items) {\r\n      items.forEach((item) => {\r\n        ++buffer.next;\r\n        buffer.insert('append', item);\r\n      });\r\n      buffer.maxIndex = buffer.eof ? buffer.next - 1 : Math.max(buffer.next - 1, buffer.maxIndex);\r\n    },\r\n\r\n    prepend(items) {\r\n      items.reverse().forEach((item) => {\r\n        --buffer.first;\r\n        buffer.insert('prepend', item);\r\n      });\r\n      buffer.minIndex = buffer.bof ? buffer.minIndex = buffer.first : Math.min(buffer.first, buffer.minIndex);\r\n    },\r\n\r\n    /**\r\n     * inserts wrapped element in the buffer\r\n     * the first argument is either operation keyword (see below) or a number for operation 'insert'\r\n     * for insert the number is the index for the buffer element the new one have to be inserted after\r\n     * operations: 'append', 'prepend', 'insert', 'remove', 'update', 'none'\r\n     */\r\n    insert(operation, item, isTop) {\r\n      const wrapper = {\r\n        item: item\r\n      };\r\n\r\n      if (operation % 1 === 0) {// it is an insert\r\n        wrapper.op = 'insert';\r\n        buffer.splice(operation, 0, wrapper);\r\n        if(isTop) {\r\n          buffer.first--;\r\n        }\r\n        else {\r\n          buffer.next++;\r\n        }\r\n      } else {\r\n        wrapper.op = operation;\r\n        switch (operation) {\r\n          case 'append':\r\n            buffer.push(wrapper);\r\n            break;\r\n          case 'prepend':\r\n            buffer.unshift(wrapper);\r\n            break;\r\n        }\r\n      }\r\n    },\r\n\r\n    // removes elements from buffer\r\n    remove(arg1, arg2) {\r\n      if (angular.isNumber(arg1)) {\r\n        // removes items from arg1 (including) through arg2 (excluding)\r\n        for (let i = arg1; i < arg2; i++) {\r\n          elementRoutines.removeElement(buffer[i]);\r\n        }\r\n        return buffer.splice(arg1, arg2 - arg1);\r\n      }\r\n      // removes single item(wrapper) from the buffer\r\n      buffer.splice(buffer.indexOf(arg1), 1);\r\n      if(arg1._op === 'isTop' && buffer.first === this.getAbsMinIndex()) {\r\n        this.incrementMinIndex();\r\n      }\r\n      else {\r\n        this.decrementMaxIndex();\r\n      }\r\n      if(arg1._op === 'isTop') {\r\n        buffer.first++;\r\n      }\r\n      else {\r\n        buffer.next--;\r\n      }\r\n      if(!buffer.length) {\r\n        buffer.first = 1;\r\n        buffer.next = 1;\r\n      }\r\n\r\n      return elementRoutines.removeElementAnimated(arg1);\r\n    },\r\n\r\n    incrementMinIndex() {\r\n      if(buffer.minIndexUser !== null) {\r\n        if(buffer.minIndex > buffer.minIndexUser) {\r\n          buffer.minIndexUser++;\r\n          return;\r\n        }\r\n        if(buffer.minIndex === buffer.minIndexUser) {\r\n          buffer.minIndexUser++;\r\n        }\r\n      }\r\n      buffer.minIndex++;\r\n    },\r\n\r\n    decrementMaxIndex() {\r\n      if(buffer.maxIndexUser !== null && buffer.maxIndex <= buffer.maxIndexUser) {\r\n        buffer.maxIndexUser--;\r\n      }\r\n      buffer.maxIndex--;\r\n    },\r\n\r\n    getAbsMinIndex() {\r\n      if(buffer.minIndexUser !== null) {\r\n        return Math.min(buffer.minIndexUser, buffer.minIndex);\r\n      }\r\n      return buffer.minIndex;\r\n    },\r\n\r\n    getAbsMaxIndex() {\r\n      if(buffer.maxIndexUser !== null) {\r\n        return Math.max(buffer.maxIndexUser, buffer.maxIndex);\r\n      }\r\n      return buffer.maxIndex;\r\n    },\r\n\r\n    effectiveHeight(elements) {\r\n      if (!elements.length) {\r\n        return 0;\r\n      }\r\n      let top = Number.MAX_VALUE;\r\n      let bottom = Number.NEGATIVE_INFINITY;\r\n      elements.forEach((wrapper) => {\r\n        if (wrapper.element[0].offsetParent) {\r\n          // element style is not display:none\r\n          top = Math.min(top, wrapper.element.offset().top);\r\n          bottom = Math.max(bottom, wrapper.element.offset().top + wrapper.element.outerHeight(true));\r\n        }\r\n      });\r\n      return Math.max(0, bottom - top);\r\n    }\r\n\r\n  });\r\n\r\n  buffer.reset(startIndex);\r\n\r\n  return buffer;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/modules/buffer.js","import Padding from './padding';\r\n\r\nexport default function Viewport(elementRoutines, buffer, element, viewportController, $rootScope, padding) {\r\n  let topPadding = null;\r\n  let bottomPadding = null;\r\n  const viewport = viewportController && viewportController.viewport ? viewportController.viewport : angular.element(window);\r\n  const container = viewportController && viewportController.container ? viewportController.container : undefined;\r\n  const scope = viewportController && viewportController.scope ? viewportController.scope : $rootScope;\r\n\r\n  viewport.css({\r\n    'overflow-anchor': 'none',\r\n    'overflow-y': 'auto',\r\n    'display': 'block'\r\n  });\r\n\r\n  viewport.scrollTopOriginal = viewport.scrollTopOriginal || viewport.scrollTop;\r\n  viewport.scrollTopBeforeSet = null;\r\n  viewport.scrollTopValue = null;\r\n\r\n  function bufferPadding() {\r\n    return viewport.outerHeight() * padding; // some extra space to initiate preload\r\n  }\r\n\r\n  angular.extend(viewport, {\r\n    getScope() {\r\n      return scope;\r\n    },\r\n\r\n    scrollTop() {\r\n      if (typeof arguments[0] !== 'undefined') {\r\n        viewport.scrollTopBeforeSet = viewport.scrollTop();\r\n        viewport.scrollTopValue = arguments[0];\r\n      }\r\n      return viewport.scrollTopOriginal.apply(viewport, arguments);\r\n    },\r\n\r\n    createPaddingElements(template) {\r\n      topPadding = new Padding(template);\r\n      bottomPadding = new Padding(template);\r\n      element.before(topPadding.element);\r\n      element.after(bottomPadding.element);\r\n      topPadding.height(0);\r\n      bottomPadding.height(0);\r\n    },\r\n\r\n    applyContainerStyle() {\r\n      if (!container) {\r\n        return true;\r\n      }\r\n      if(container !== viewport) {\r\n        viewport.css('height', window.getComputedStyle(container[0]).height);\r\n      }\r\n      return viewport.height() > 0;\r\n    },\r\n\r\n    bottomDataPos() {\r\n      let scrollHeight = viewport[0].scrollHeight;\r\n      scrollHeight = scrollHeight != null ? scrollHeight : viewport[0].document.documentElement.scrollHeight;\r\n      return scrollHeight - bottomPadding.height();\r\n    },\r\n\r\n    topDataPos() {\r\n      return topPadding.height();\r\n    },\r\n\r\n    bottomVisiblePos() {\r\n      return viewport.scrollTop() + viewport.outerHeight();\r\n    },\r\n\r\n    topVisiblePos() {\r\n      return viewport.scrollTop();\r\n    },\r\n\r\n    insertElement(e, sibling) {\r\n      return elementRoutines.insertElement(e, sibling || topPadding.element);\r\n    },\r\n\r\n    insertElementAnimated(e, sibling) {\r\n      return elementRoutines.insertElementAnimated(e, sibling || topPadding.element);\r\n    },\r\n\r\n    shouldLoadBottom() {\r\n      return !buffer.eof && viewport.bottomDataPos() < viewport.bottomVisiblePos() + bufferPadding();\r\n    },\r\n\r\n    clipBottom() {\r\n      // clip the invisible items off the bottom\r\n      let overage = 0;\r\n      let overageHeight = 0;\r\n      let itemHeight = 0;\r\n      let emptySpaceHeight = viewport.bottomDataPos() - viewport.bottomVisiblePos() - bufferPadding();\r\n\r\n      for (let i = buffer.length - 1; i >= 0; i--) {\r\n        itemHeight = buffer[i].element.outerHeight(true);\r\n        if (overageHeight + itemHeight > emptySpaceHeight) {\r\n          break;\r\n        }\r\n        bottomPadding.cache.add(buffer[i]);\r\n        overageHeight += itemHeight;\r\n        overage++;\r\n      }\r\n\r\n      if (overage > 0) {\r\n        buffer.eof = false;\r\n        buffer.remove(buffer.length - overage, buffer.length);\r\n        buffer.next -= overage;\r\n        viewport.adjustPaddings();\r\n      }\r\n    },\r\n\r\n    shouldLoadTop() {\r\n      return !buffer.bof && !viewport.scrollTopSetFailed && viewport.topDataPos() > viewport.topVisiblePos() - bufferPadding();\r\n    },\r\n\r\n    clipTop() {\r\n      // clip the invisible items off the top\r\n      let overage = 0;\r\n      let overageHeight = 0;\r\n      let itemHeight = 0;\r\n      let emptySpaceHeight = viewport.topVisiblePos() - viewport.topDataPos() - bufferPadding();\r\n\r\n      for (let i = 0; i < buffer.length; i++) {\r\n        itemHeight = buffer[i].element.outerHeight(true);\r\n        if (overageHeight + itemHeight > emptySpaceHeight) {\r\n          break;\r\n        }\r\n        topPadding.cache.add(buffer[i]);\r\n        overageHeight += itemHeight;\r\n        overage++;\r\n      }\r\n\r\n      if (overage > 0) {\r\n        // we need to adjust top padding element before items are removed from top\r\n        // to avoid strange behaviour of scroll bar during remove top items when we are at the very bottom\r\n        topPadding.height(topPadding.height() + overageHeight);\r\n        buffer.bof = false;\r\n        buffer.remove(0, overage);\r\n        buffer.first += overage;\r\n      }\r\n    },\r\n\r\n    adjustPaddings() {\r\n      if (!buffer.length) {\r\n        return;\r\n      }\r\n\r\n      // precise heights calculation based on items that are in buffer or that were in buffer once\r\n      const visibleItemsHeight = buffer.reduce((summ, item) => summ + item.element.outerHeight(true), 0);\r\n\r\n      let topPaddingHeight = 0, topCount = 0;\r\n      topPadding.cache.forEach(item => {\r\n        if(item.index < buffer.first) {\r\n          topPaddingHeight += item.height;\r\n          topCount++;\r\n        }\r\n      });\r\n\r\n      let bottomPaddingHeight = 0, bottomCount = 0;\r\n      bottomPadding.cache.forEach(item => {\r\n        if(item.index >= buffer.next) {\r\n          bottomPaddingHeight += item.height;\r\n          bottomCount++;\r\n        }\r\n      });\r\n\r\n      const totalHeight = visibleItemsHeight + topPaddingHeight + bottomPaddingHeight;\r\n      const averageItemHeight = totalHeight / (topCount + bottomCount + buffer.length);\r\n\r\n      // average heights calculation, items that have never been reached\r\n      let adjustTopPadding = buffer.minIndexUser !== null && buffer.minIndex > buffer.minIndexUser;\r\n      let adjustBottomPadding = buffer.maxIndexUser !== null && buffer.maxIndex < buffer.maxIndexUser;\r\n      let topPaddingHeightAdd = adjustTopPadding ? (buffer.minIndex - buffer.minIndexUser) * averageItemHeight : 0;\r\n      let bottomPaddingHeightAdd = adjustBottomPadding ? (buffer.maxIndexUser - buffer.maxIndex) * averageItemHeight : 0;\r\n\r\n      // paddings combine adjustment\r\n      topPadding.height(topPaddingHeight + topPaddingHeightAdd);\r\n      bottomPadding.height(bottomPaddingHeight + bottomPaddingHeightAdd);\r\n    },\r\n\r\n    onAfterMinIndexSet(topPaddingHeightOld) {\r\n      // additional scrollTop adjustment in case of datasource.minIndex external set\r\n      if (buffer.minIndexUser !== null && buffer.minIndex > buffer.minIndexUser) {\r\n        let diff = topPadding.height() - topPaddingHeightOld;\r\n        viewport.scrollTop(viewport.scrollTop() + diff);\r\n        while((diff -= viewport.scrollTop()) > 0) {\r\n          bottomPadding.height(bottomPadding.height() + diff);\r\n          viewport.scrollTop(viewport.scrollTop() + diff);\r\n        }\r\n      }\r\n    },\r\n\r\n    onAfterPrepend(updates) {\r\n      if (!updates.prepended.length)\r\n        return;\r\n      const height = buffer.effectiveHeight(updates.prepended);\r\n      const paddingHeight = topPadding.height() - height;\r\n      if (paddingHeight >= 0) {\r\n        topPadding.height(paddingHeight);\r\n      }\r\n      else {\r\n        topPadding.height(0);\r\n        viewport.scrollTopAdjust = paddingHeight;\r\n        viewport.scrollTop(viewport.scrollTop() - paddingHeight);\r\n      }\r\n    },\r\n\r\n    resetTopPadding() {\r\n      topPadding.height(0);\r\n      topPadding.cache.clear();\r\n    },\r\n\r\n    resetBottomPadding() {\r\n      bottomPadding.height(0);\r\n      bottomPadding.cache.clear();\r\n    },\r\n\r\n    removeCacheItem(item, isTop) {\r\n      topPadding.cache.remove(item, isTop);\r\n      bottomPadding.cache.remove(item, isTop);\r\n    },\r\n\r\n    removeItem(item) {\r\n      this.removeCacheItem(item);\r\n      return buffer.remove(item);\r\n    }\r\n  });\r\n\r\n  return viewport;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/modules/viewport.js","// Can't just extend the Array, due to Babel does not support built-in classes extending\r\n// This solution was taken from https://stackoverflow.com/questions/46897414/es6-class-extends-array-workaround-for-es5-babel-transpile\r\nclass CacheProto {\r\n  add(item) {\r\n    for (let i = this.length - 1; i >= 0; i--) {\r\n      if (this[i].index === item.scope.$index) {\r\n        this[i].height = item.element.outerHeight();\r\n        return;\r\n      }\r\n    }\r\n    this.push({\r\n      index: item.scope.$index,\r\n      height: item.element.outerHeight()\r\n    });\r\n    this.sort((a, b) => ((a.index < b.index) ? -1 : ((a.index > b.index) ? 1 : 0)));\r\n  }\r\n\r\n  remove(argument, _isTop) {\r\n    const index = argument % 1 === 0 ? argument : argument.scope.$index;\r\n    const isTop = argument % 1 === 0 ? _isTop : argument._op === 'isTop';\r\n    for (let i = this.length - 1; i >= 0; i--) {\r\n      if (this[i].index === index) {\r\n        this.splice(i, 1);\r\n        break;\r\n      }\r\n    }\r\n    if(!isTop) {\r\n      for (let i = this.length - 1; i >= 0; i--) {\r\n        if (this[i].index > index) {\r\n          this[i].index--;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  clear() {\r\n    this.length = 0;\r\n  }\r\n}\r\n\r\nfunction Cache() {\r\n  const instance = [];\r\n  instance.push.apply(instance, arguments);\r\n  Object.setPrototypeOf(instance, Cache.prototype);\r\n  return instance;\r\n}\r\nCache.prototype = Object.create(Array.prototype);\r\nObject.getOwnPropertyNames(CacheProto.prototype).forEach(methodName =>\r\n  Cache.prototype[methodName] = CacheProto.prototype[methodName]\r\n);\r\n\r\nfunction generateElement(template) {\r\n  if(template.nodeType !== Node.ELEMENT_NODE) {\r\n    throw new Error('ui-scroll directive requires an Element node for templating the view');\r\n  }\r\n  let element;\r\n  switch (template.tagName.toLowerCase()) {\r\n    case 'dl':\r\n      throw new Error(`ui-scroll directive does not support <${template.tagName}> as a repeating tag: ${template.outerHTML}`);\r\n    case 'tr':\r\n      let table = angular.element('<table><tr><td><div></div></td></tr></table>');\r\n      element = table.find('tr');\r\n      break;\r\n    case 'li':\r\n      element = angular.element('<li></li>');\r\n      break;\r\n    default:\r\n      element = angular.element('<div></div>');\r\n  }\r\n  return element;\r\n}\r\n\r\nclass Padding {\r\n  constructor(template) {\r\n    this.element = generateElement(template);\r\n    this.cache = new Cache();\r\n  }\r\n\r\n  height() {\r\n    return this.element.height.apply(this.element, arguments);\r\n  }\r\n}\r\n\r\nexport default Padding;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/padding.js","class Adapter {\r\n\r\n  constructor($scope, $parse, $attr, viewport, buffer, doAdjust, reload) {\r\n    this.$parse = $parse;\r\n    this.$attr = $attr;\r\n    this.viewport = viewport;\r\n    this.buffer = buffer;\r\n\r\n    this.doAdjust = doAdjust;\r\n    this.reload = reload;\r\n\r\n    this.isLoading = false;\r\n    this.disabled = false;\r\n\r\n    const viewportScope = viewport.getScope();\r\n    this.startScope = viewportScope.$parent ? viewportScope : $scope;\r\n\r\n    this.publicContext = {};\r\n    this.assignAdapter($attr.adapter);\r\n    this.generatePublicContext();\r\n  }\r\n\r\n  assignAdapter(adapterAttr) {\r\n    if (!adapterAttr || !(adapterAttr = adapterAttr.replace(/^\\s+|\\s+$/gm, ''))) {\r\n      return;\r\n    }\r\n    let adapterOnScope;\r\n\r\n    try {\r\n      this.$parse(adapterAttr).assign(this.startScope, {});\r\n      adapterOnScope = this.$parse(adapterAttr)(this.startScope);\r\n    }\r\n    catch (error) {\r\n      error.message = `Angular ui-scroll Adapter assignment exception.\\n` +\r\n        `Can't parse \"${adapterAttr}\" expression.\\n` +\r\n        error.message;\r\n      throw error;\r\n    }\r\n\r\n    angular.extend(adapterOnScope, this.publicContext);\r\n    this.publicContext = adapterOnScope;\r\n  }\r\n\r\n  generatePublicContext() {\r\n    // these methods will be accessible out of ui-scroll via user defined adapter\r\n    const publicMethods = ['reload', 'applyUpdates', 'append', 'prepend', 'isBOF', 'isEOF', 'isEmpty', 'resetScrollTopCorrection'];\r\n    for (let i = publicMethods.length - 1; i >= 0; i--) {\r\n      this.publicContext[publicMethods[i]] = this[publicMethods[i]].bind(this);\r\n    }\r\n\r\n    // these read-only props will be accessible out of ui-scroll via user defined adapter\r\n    const publicProps = ['isLoading', 'topVisible', 'topVisibleElement', 'topVisibleScope', 'bottomVisible', 'bottomVisibleElement', 'bottomVisibleScope'];\r\n    for (let i = publicProps.length - 1; i >= 0; i--) {\r\n      let property, attr = this.$attr[publicProps[i]];\r\n      Object.defineProperty(this, publicProps[i], {\r\n        get: () => property,\r\n        set: (value) => {\r\n          property = value;\r\n          this.publicContext[publicProps[i]] = value;\r\n          if (attr) {\r\n            this.$parse(attr).assign(this.startScope, value);\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    // non-read-only public property\r\n    Object.defineProperty(this.publicContext, 'disabled', {\r\n      get: () => this.disabled,\r\n      set: (value) => (!(this.disabled = value)) ? this.doAdjust() : null\r\n    });\r\n  }\r\n\r\n  loading(value) {\r\n    this.isLoading = value;\r\n  }\r\n\r\n  isBOF() {\r\n    return this.buffer.bof;\r\n  }\r\n\r\n  isEOF() {\r\n    return this.buffer.eof;\r\n  }\r\n\r\n  isEmpty() {\r\n    return !this.buffer.length;\r\n  }\r\n\r\n  resetScrollTopCorrection() {\r\n    // is needed to scroll at negative area programmatically (e.g. tests)\r\n    this.viewport.scrollTopValue = null;\r\n  }\r\n\r\n  append(newItems) {\r\n    this.buffer.append(newItems);\r\n    this.doAdjust();\r\n    this.viewport.clipTop();\r\n    this.viewport.clipBottom();\r\n  }\r\n\r\n  prepend(newItems) {\r\n    this.buffer.prepend(newItems);\r\n    this.doAdjust();\r\n    this.viewport.clipTop();\r\n    this.viewport.clipBottom();\r\n  }\r\n\r\n  applyUpdates(arg1, arg2) {\r\n    if (typeof arg1 === 'function') {\r\n      this.applyUpdatesFunc(arg1);\r\n    } else {\r\n      this.applyUpdatesIndex(arg1, arg2);\r\n    }\r\n    this.doAdjust();\r\n  }\r\n\r\n  applyUpdatesFunc(cb) {\r\n    this.buffer.slice(0).forEach((wrapper) => {\r\n      // we need to do it on the buffer clone, because buffer content\r\n      // may change as we iterate through\r\n      this.applyUpdate(wrapper, cb(wrapper.item, wrapper.scope, wrapper.element));\r\n    });\r\n  }\r\n\r\n  applyUpdatesIndex(index, newItems) {\r\n    if (index % 1 !== 0) {\r\n      throw new Error('applyUpdates - ' + index + ' is not a valid index (should be an integer)');\r\n    }\r\n    const _index = index - this.buffer.first;\r\n\r\n    // apply updates only within buffer\r\n    if (_index >= 0 && _index < this.buffer.length) {\r\n      this.applyUpdate(this.buffer[_index], newItems);\r\n    }\r\n    // out-of-buffer case: deletion may affect Paddings\r\n    else if(index >= this.buffer.getAbsMinIndex() && index <= this.buffer.getAbsMaxIndex()) {\r\n      if(angular.isArray(newItems) && !newItems.length) {\r\n        this.viewport.removeCacheItem(index, index === this.buffer.minIndex);\r\n        if(index === this.buffer.getAbsMinIndex()) {\r\n          this.buffer.incrementMinIndex();\r\n        }\r\n        else {\r\n          this.buffer.decrementMaxIndex();\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  applyUpdate(wrapper, newItems) {\r\n    if (!angular.isArray(newItems)) {\r\n      return;\r\n    }\r\n    let position = this.buffer.indexOf(wrapper);\r\n    if (!newItems.reverse().some(newItem => newItem === wrapper.item)) {\r\n      wrapper.op = 'remove';\r\n      if(position === 0 && !newItems.length) {\r\n        wrapper._op = 'isTop'; // to catch \"first\" edge case on remove\r\n      }\r\n    }\r\n    newItems.forEach((newItem) => {\r\n      if (newItem === wrapper.item) {\r\n        position--;\r\n      } else {\r\n        // 3 parameter (isTop) is to catch \"first\" edge case on insert\r\n        this.buffer.insert(position + 1, newItem, position === -1);\r\n      }\r\n    });\r\n  }\r\n\r\n  calculateProperties() {\r\n    let rowTop = null, topHeight = 0;\r\n    let topDone = false, bottomDone = false;\r\n    const length = this.buffer.length;\r\n\r\n    for (let i = 0; i < length; i++) {\r\n      const item = this.buffer[i];\r\n      const itemTop = item.element.offset().top;\r\n\r\n      if (rowTop !== itemTop) { // a new row condition\r\n        const itemHeight = item.element.outerHeight(true);\r\n        const top = this.viewport.topDataPos() + topHeight + itemHeight;\r\n\r\n        if (!topDone && top > this.viewport.topVisiblePos()) {\r\n          topDone = true;\r\n          this['topVisible'] = item.item;\r\n          this['topVisibleElement'] = item.element;\r\n          this['topVisibleScope'] = item.scope;\r\n        }\r\n        if (!bottomDone && (top >= this.viewport.bottomVisiblePos() || (i === length - 1 && this.isEOF()))) {\r\n          bottomDone = true;\r\n          this['bottomVisible'] = item.item;\r\n          this['bottomVisibleElement'] = item.element;\r\n          this['bottomVisibleScope'] = item.scope;\r\n        }\r\n        topHeight += itemHeight;\r\n      }\r\n      rowTop = itemTop;\r\n\r\n      if (topDone && bottomDone) {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport default Adapter;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/modules/adapter.js"],"sourceRoot":""}