{"version":3,"file":"ui-scroll.min.js","mappings":"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","sources":["webpack://angular-ui-scroll/./src/modules/jqLiteExtras.js","webpack://angular-ui-scroll/./src/modules/elementRoutines.js","webpack://angular-ui-scroll/./src/modules/utils.js","webpack://angular-ui-scroll/./src/modules/buffer.js","webpack://angular-ui-scroll/./src/modules/padding.js","webpack://angular-ui-scroll/./src/modules/viewport.js","webpack://angular-ui-scroll/./src/modules/adapter.js","webpack://angular-ui-scroll/./src/ui-scroll.js"],"sourcesContent":["/*!\r\n globals: angular, window\r\n List of used element methods available in JQuery but not in JQuery Lite\r\n element.before(elem)\r\n element.height()\r\n element.outerHeight(true)\r\n element.height(value) = only for Top/Bottom padding elements\r\n element.scrollTop()\r\n element.scrollTop(value)\r\n */\r\n\r\nexport default class JQLiteExtras {\r\n\r\n  registerFor(element) {\r\n    let convertToPx, css, getStyle, isWindow;\r\n    // angular implementation blows up if elem is the window\r\n    css = angular.element.prototype.css;\r\n\r\n    element.prototype.css = function (name, value) {\r\n      let self = this;\r\n      let elem = self[0];\r\n      if (!(!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style)) {\r\n        return css.call(self, name, value);\r\n      }\r\n    };\r\n\r\n    // as defined in angularjs v1.0.5\r\n    isWindow = (obj) => obj && obj.document && obj.location && obj.alert && obj.setInterval;\r\n\r\n    function scrollTo(self, direction, value) {\r\n      let elem = self[0];\r\n      let [method, prop, preserve] = {\r\n        top: [\r\n          'scrollTop',\r\n          'pageYOffset',\r\n          'scrollLeft'\r\n        ],\r\n        left: [\r\n          'scrollLeft',\r\n          'pageXOffset',\r\n          'scrollTop'\r\n        ]\r\n      }[direction];\r\n\r\n      const isValueDefined = typeof value !== 'undefined';\r\n      if (isWindow(elem)) {\r\n        if (isValueDefined) {\r\n          return elem.scrollTo(self[preserve].call(self), value);\r\n        }\r\n        return (prop in elem) ? elem[prop] : elem.document.documentElement[method];\r\n      } else {\r\n        if (isValueDefined) {\r\n          elem[method] = value;\r\n        }\r\n        return elem[method];\r\n      }\r\n    }\r\n\r\n    if (window.getComputedStyle) {\r\n      getStyle = (elem) => window.getComputedStyle(elem, null);\r\n      convertToPx = (elem, value) => parseFloat(value);\r\n    } else {\r\n      getStyle = (elem) => elem.currentStyle;\r\n      convertToPx = (elem, value) => {\r\n        let left, result, rs, rsLeft, style;\r\n        let core_pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\r\n        let rnumnonpx = new RegExp('^(' + core_pnum + ')(?!px)[a-z%]+$', 'i');\r\n\r\n        if (!rnumnonpx.test(value)) {\r\n          return parseFloat(value);\r\n        }\r\n\r\n        // ported from JQuery\r\n        style = elem.style;\r\n        left = style.left;\r\n        rs = elem.runtimeStyle;\r\n        rsLeft = rs && rs.left;\r\n        if (rs) {\r\n          rs.left = style.left;\r\n        }\r\n        // put in the new values to get a computed style out\r\n        style.left = value;\r\n        result = style.pixelLeft;\r\n        style.left = left;\r\n        if (rsLeft) {\r\n          rs.left = rsLeft;\r\n        }\r\n        return result;\r\n      };\r\n    }\r\n\r\n    function getMeasurements(elem, measure) {\r\n      let base, borderA, borderB, computedMarginA, computedMarginB, computedStyle, dirA, dirB, marginA, marginB, paddingA, paddingB;\r\n\r\n      if (isWindow(elem)) {\r\n        base = document.documentElement[{height: 'clientHeight', width: 'clientWidth'}[measure]];\r\n\r\n        return {\r\n          base: base,\r\n          padding: 0,\r\n          border: 0,\r\n          margin: 0\r\n        };\r\n      }\r\n\r\n      // Start with offset property\r\n      [\r\n        base,\r\n        dirA,\r\n        dirB\r\n      ] = {\r\n        width: [\r\n          elem.offsetWidth,\r\n          'Left',\r\n          'Right'\r\n        ],\r\n        height: [\r\n          elem.offsetHeight,\r\n          'Top',\r\n          'Bottom'\r\n        ]\r\n      }[measure];\r\n\r\n      computedStyle = getStyle(elem);\r\n      paddingA = convertToPx(elem, computedStyle['padding' + dirA]) || 0;\r\n      paddingB = convertToPx(elem, computedStyle['padding' + dirB]) || 0;\r\n      borderA = convertToPx(elem, computedStyle['border' + dirA + 'Width']) || 0;\r\n      borderB = convertToPx(elem, computedStyle['border' + dirB + 'Width']) || 0;\r\n      computedMarginA = computedStyle['margin' + dirA];\r\n      computedMarginB = computedStyle['margin' + dirB];\r\n\r\n      // I do not care for width for now, so this hack is irrelevant\r\n      // if ( !supportsPercentMargin )\r\n      // computedMarginA = hackPercentMargin( elem, computedStyle, computedMarginA )\r\n      // computedMarginB = hackPercentMargin( elem, computedStyle, computedMarginB )\r\n      marginA = convertToPx(elem, computedMarginA) || 0;\r\n      marginB = convertToPx(elem, computedMarginB) || 0;\r\n\r\n      return {\r\n        base: base,\r\n        padding: paddingA + paddingB,\r\n        border: borderA + borderB,\r\n        margin: marginA + marginB\r\n      };\r\n    }\r\n\r\n    function getWidthHeight(elem, direction, measure) {\r\n      let computedStyle, result;\r\n\r\n      let measurements = getMeasurements(elem, direction);\r\n\r\n      if (measurements.base > 0) {\r\n        return {\r\n          base: measurements.base - measurements.padding - measurements.border,\r\n          outer: measurements.base,\r\n          outerfull: measurements.base + measurements.margin\r\n        }[measure];\r\n      }\r\n\r\n      // Fall back to computed then uncomputed css if necessary\r\n      computedStyle = getStyle(elem);\r\n      result = computedStyle[direction];\r\n\r\n      if (result < 0 || result === null) {\r\n        result = elem.style[direction] || 0;\r\n      }\r\n\r\n      // Normalize \"\", auto, and prepare for extra\r\n      result = parseFloat(result) || 0;\r\n\r\n      return {\r\n        base: result - measurements.padding - measurements.border,\r\n        outer: result,\r\n        outerfull: result + measurements.padding + measurements.border + measurements.margin\r\n      }[measure];\r\n    }\r\n\r\n    // define missing methods\r\n    return angular.forEach({\r\n      before(newElem) {\r\n        var children, elem, i, j, parent, ref, self;\r\n        self = this;\r\n        elem = self[0];\r\n        parent = self.parent();\r\n        children = parent.contents();\r\n        if (children[0] === elem) {\r\n          return parent.prepend(newElem);\r\n        } else {\r\n          for (i = j = 1, ref = children.length - 1; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {\r\n            if (children[i] === elem) {\r\n              angular.element(children[i - 1]).after(newElem);\r\n              return;\r\n            }\r\n          }\r\n          throw new Error('invalid DOM structure ' + elem.outerHTML);\r\n        }\r\n      },\r\n      height (value){\r\n        var self;\r\n        self = this;\r\n        if (typeof value !== 'undefined') {\r\n          if (angular.isNumber(value)) {\r\n            value = value + 'px';\r\n          }\r\n          return css.call(self, 'height', value);\r\n        } else {\r\n          return getWidthHeight(this[0], 'height', 'base');\r\n        }\r\n      },\r\n      outerHeight(option) {\r\n        return getWidthHeight(this[0], 'height', option ? 'outerfull' : 'outer');\r\n      },\r\n      outerWidth(option) {\r\n        return getWidthHeight(this[0], 'width', option ? 'outerfull' : 'outer');\r\n      },\r\n\r\n      /*\r\n       The offset setter method is not implemented\r\n       */\r\n      offset(value) {\r\n        let docElem, win;\r\n        let self = this;\r\n        let box = {\r\n          top: 0,\r\n          left: 0\r\n        };\r\n        let elem = self[0];\r\n        let doc = elem && elem.ownerDocument;\r\n\r\n        if (arguments.length) {\r\n          if (value === undefined) {\r\n            return self;\r\n          }\r\n          // TODO: implement setter\r\n          throw new Error('offset setter method is not implemented');\r\n        }\r\n\r\n        if (!doc) {\r\n          return;\r\n        }\r\n\r\n        docElem = doc.documentElement;\r\n\r\n        // TODO: Make sure it's not a disconnected DOM node\r\n\r\n        if (elem.getBoundingClientRect != null) {\r\n          box = elem.getBoundingClientRect();\r\n        }\r\n\r\n        win = doc.defaultView || doc.parentWindow;\r\n\r\n        return {\r\n          top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),\r\n          left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)\r\n        };\r\n      },\r\n      scrollTop(value) {\r\n        return scrollTo(this, 'top', value);\r\n      },\r\n      scrollLeft(value) {\r\n        return scrollTo(this, 'left', value);\r\n      }\r\n    }, (value, key) => {\r\n      if (!element.prototype[key]) {\r\n        return element.prototype[key] = value;\r\n      }\r\n    });\r\n  }\r\n\r\n}\r\n","const hideClassToken = 'ng-ui-scroll-hide';\r\n\r\nexport default class ElementRoutines {\r\n\r\n  static addCSSRules() {\r\n    const selector = '.' + hideClassToken;\r\n    const rules = 'display: none';\r\n    const sheet = document.styleSheets[0];\r\n    let index;\r\n    try {\r\n      index = sheet.cssRules.length;\r\n    } catch (err) {\r\n      index = 0;\r\n    }\r\n    if('insertRule' in sheet) {\r\n      sheet.insertRule(selector + '{' + rules + '}', index);\r\n    }\r\n    else if('addRule' in sheet) {\r\n      sheet.addRule(selector, rules, index);\r\n    }\r\n  }\r\n\r\n  constructor($injector, $q) {\r\n    this.$animate = ($injector.has && $injector.has('$animate')) ? $injector.get('$animate') : null;\r\n    this.isAngularVersionLessThen1_3 = angular.version.major === 1 && angular.version.minor < 3;\r\n    this.$q = $q;\r\n  }\r\n\r\n  hideElement(wrapper) {\r\n    wrapper.element.addClass(hideClassToken);\r\n  }\r\n\r\n  showElement(wrapper) {\r\n    wrapper.element.removeClass(hideClassToken);\r\n  }\r\n\r\n  insertElement(newElement, previousElement) {\r\n    previousElement.after(newElement);\r\n    return [];\r\n  }\r\n\r\n  removeElement(wrapper) {\r\n    wrapper.element.remove();\r\n    wrapper.scope.$destroy();\r\n    return [];\r\n  }\r\n\r\n  insertElementAnimated(newElement, previousElement) {\r\n    if (!this.$animate) {\r\n      return this.insertElement(newElement, previousElement);\r\n    }\r\n\r\n    if (this.isAngularVersionLessThen1_3) {\r\n      const deferred = this.$q.defer();\r\n      // no need for parent - previous element is never null\r\n      this.$animate.enter(newElement, null, previousElement, () => deferred.resolve());\r\n\r\n      return [deferred.promise];\r\n    }\r\n\r\n    // no need for parent - previous element is never null\r\n    return [this.$animate.enter(newElement, null, previousElement)];\r\n  }\r\n\r\n  removeElementAnimated(wrapper) {\r\n    if (!this.$animate) {\r\n      return this.removeElement(wrapper);\r\n    }\r\n\r\n    if (this.isAngularVersionLessThen1_3) {\r\n      const deferred = this.$q.defer();\r\n      this.$animate.leave(wrapper.element, () => {\r\n        wrapper.scope.$destroy();\r\n        return deferred.resolve();\r\n      });\r\n\r\n      return [deferred.promise];\r\n    }\r\n\r\n    return [(this.$animate.leave(wrapper.element)).then(() => wrapper.scope.$destroy())];\r\n  }\r\n}","export const OPERATIONS = {\r\n  PREPEND: 'prepend',\r\n  APPEND: 'append',\r\n  INSERT: 'insert',\r\n  REMOVE: 'remove',\r\n  NONE: 'none'\r\n};\r\n","import { OPERATIONS } from './utils';\r\n\r\nexport default function ScrollBuffer(elementRoutines, bufferSize, startIndex) {\r\n  const buffer = Object.create(Array.prototype);\r\n\r\n  angular.extend(buffer, {\r\n    size: bufferSize,\r\n\r\n    reset(startIndex) {\r\n      buffer.remove(0, buffer.length);\r\n      buffer.eof = false;\r\n      buffer.bof = false;\r\n      buffer.first = startIndex;\r\n      buffer.next = startIndex;\r\n      buffer.minIndex = startIndex;\r\n      buffer.maxIndex = startIndex;\r\n      buffer.minIndexUser = null;\r\n      buffer.maxIndexUser = null;\r\n    },\r\n\r\n    append(items) {\r\n      items.forEach((item) => {\r\n        ++buffer.next;\r\n        buffer.insert(OPERATIONS.APPEND, item);\r\n      });\r\n      buffer.maxIndex = buffer.eof ? buffer.next - 1 : Math.max(buffer.next - 1, buffer.maxIndex);\r\n    },\r\n\r\n    prepend(items, immutableTop) {\r\n      items.reverse().forEach((item) => {\r\n        if (immutableTop) {\r\n          ++buffer.next;\r\n        }\r\n        else {\r\n          --buffer.first;\r\n        }\r\n        buffer.insert(OPERATIONS.PREPEND, item);\r\n      });\r\n      buffer.minIndex = buffer.bof ? buffer.minIndex = buffer.first : Math.min(buffer.first, buffer.minIndex);\r\n    },\r\n\r\n    /**\r\n     * inserts wrapped element in the buffer\r\n     * the first argument is either operation keyword (see below) or a number for operation 'insert'\r\n     * for insert the number is the index for the buffer element the new one have to be inserted after\r\n     * operations: 'append', 'prepend', 'insert', 'remove', 'none'\r\n     */\r\n    insert(operation, item, shiftTop) {\r\n      const wrapper = {\r\n        item: item\r\n      };\r\n\r\n      if (operation % 1 === 0) { // it is an insert\r\n        wrapper.op = OPERATIONS.INSERT;\r\n        buffer.splice(operation, 0, wrapper);\r\n        if (shiftTop) {\r\n          buffer.first--;\r\n        }\r\n        else {\r\n          buffer.next++;\r\n        }\r\n      } else {\r\n        wrapper.op = operation;\r\n        switch (operation) {\r\n          case OPERATIONS.APPEND:\r\n            buffer.push(wrapper);\r\n            break;\r\n          case OPERATIONS.PREPEND:\r\n            buffer.unshift(wrapper);\r\n            break;\r\n        }\r\n      }\r\n    },\r\n\r\n    // removes elements from buffer\r\n    remove(arg1, arg2) {\r\n      if (angular.isNumber(arg1)) {\r\n        // removes items from arg1 (including) through arg2 (excluding)\r\n        for (let i = arg1; i < arg2; i++) {\r\n          elementRoutines.removeElement(buffer[i]);\r\n        }\r\n        return buffer.splice(arg1, arg2 - arg1);\r\n      }\r\n      // removes single item (wrapper) from the buffer\r\n      buffer.splice(buffer.indexOf(arg1), 1);\r\n      if (arg1.shiftTop && buffer.first === this.getAbsMinIndex()) {\r\n        this.incrementMinIndex();\r\n      }\r\n      else {\r\n        this.decrementMaxIndex();\r\n      }\r\n      if (arg1.shiftTop) {\r\n        buffer.first++;\r\n      }\r\n      else {\r\n        buffer.next--;\r\n      }\r\n      if (!buffer.length) {\r\n        buffer.minIndex = Math.min(buffer.maxIndex, buffer.minIndex);\r\n      }\r\n\r\n      return elementRoutines.removeElementAnimated(arg1);\r\n    },\r\n\r\n    incrementMinIndex() {\r\n      if (buffer.minIndexUser !== null) {\r\n        if (buffer.minIndex > buffer.minIndexUser) {\r\n          buffer.minIndexUser++;\r\n          return;\r\n        }\r\n        if (buffer.minIndex === buffer.minIndexUser) {\r\n          buffer.minIndexUser++;\r\n        }\r\n      }\r\n      buffer.minIndex++;\r\n    },\r\n\r\n    decrementMaxIndex() {\r\n      if (buffer.maxIndexUser !== null && buffer.maxIndex <= buffer.maxIndexUser) {\r\n        buffer.maxIndexUser--;\r\n      }\r\n      buffer.maxIndex--;\r\n    },\r\n\r\n    getAbsMinIndex() {\r\n      if (buffer.minIndexUser !== null) {\r\n        return Math.min(buffer.minIndexUser, buffer.minIndex);\r\n      }\r\n      return buffer.minIndex;\r\n    },\r\n\r\n    getAbsMaxIndex() {\r\n      if (buffer.maxIndexUser !== null) {\r\n        return Math.max(buffer.maxIndexUser, buffer.maxIndex);\r\n      }\r\n      return buffer.maxIndex;\r\n    },\r\n\r\n    effectiveHeight(elements) {\r\n      if (!elements.length) {\r\n        return 0;\r\n      }\r\n      let top = Number.MAX_VALUE;\r\n      let bottom = Number.NEGATIVE_INFINITY;\r\n      elements.forEach((wrapper) => {\r\n        if (wrapper.element[0].offsetParent) {\r\n          // element style is not display:none\r\n          top = Math.min(top, wrapper.element.offset().top);\r\n          bottom = Math.max(bottom, wrapper.element.offset().top + wrapper.element.outerHeight(true));\r\n        }\r\n      });\r\n      return Math.max(0, bottom - top);\r\n    },\r\n\r\n    getItems() {\r\n      return buffer.filter(item => item.op === OPERATIONS.NONE);\r\n    },\r\n\r\n    getFirstItem() {\r\n      const list = buffer.getItems();\r\n      if (!list.length) {\r\n        return null;\r\n      }\r\n      return list[0].item;\r\n    },\r\n\r\n    getLastItem() {\r\n      const list = buffer.getItems();\r\n      if (!list.length) {\r\n        return null;\r\n      }\r\n      return list[list.length - 1].item;\r\n    }\r\n\r\n  });\r\n\r\n  buffer.reset(startIndex);\r\n\r\n  return buffer;\r\n}\r\n","// Can't just extend the Array, due to Babel does not support built-in classes extending\r\n// This solution was taken from https://stackoverflow.com/questions/46897414/es6-class-extends-array-workaround-for-es5-babel-transpile\r\nclass CacheProto {\r\n  add(item) {\r\n    for (let i = this.length - 1; i >= 0; i--) {\r\n      if (this[i].index === item.scope.$index) {\r\n        this[i].height = item.element.outerHeight();\r\n        return;\r\n      }\r\n    }\r\n    this.push({\r\n      index: item.scope.$index,\r\n      height: item.element.outerHeight()\r\n    });\r\n    this.sort((a, b) => ((a.index < b.index) ? -1 : ((a.index > b.index) ? 1 : 0)));\r\n  }\r\n\r\n  remove(argument, _shiftTop) {\r\n    const index = argument % 1 === 0 ? argument : argument.scope.$index;\r\n    const shiftTop = argument % 1 === 0 ? _shiftTop : argument.shiftTop;\r\n    for (let i = this.length - 1; i >= 0; i--) {\r\n      if (this[i].index === index) {\r\n        this.splice(i, 1);\r\n        break;\r\n      }\r\n    }\r\n    if (!shiftTop) {\r\n      for (let i = this.length - 1; i >= 0; i--) {\r\n        if (this[i].index > index) {\r\n          this[i].index--;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  clear() {\r\n    this.length = 0;\r\n  }\r\n}\r\n\r\nfunction Cache() {\r\n  const instance = [];\r\n  instance.push.apply(instance, arguments);\r\n  Object.setPrototypeOf(instance, Cache.prototype);\r\n  return instance;\r\n}\r\nCache.prototype = Object.create(Array.prototype);\r\nObject.getOwnPropertyNames(CacheProto.prototype).forEach(methodName =>\r\n  Cache.prototype[methodName] = CacheProto.prototype[methodName]\r\n);\r\n\r\nfunction generateElement(template) {\r\n  if (template.nodeType !== Node.ELEMENT_NODE) {\r\n    throw new Error('ui-scroll directive requires an Element node for templating the view');\r\n  }\r\n  let element;\r\n  switch (template.tagName.toLowerCase()) {\r\n    case 'dl':\r\n      throw new Error(`ui-scroll directive does not support <${template.tagName}> as a repeating tag: ${template.outerHTML}`);\r\n    case 'tr':\r\n      let table = angular.element('<table><tr><td><div></div></td></tr></table>');\r\n      element = table.find('tr');\r\n      break;\r\n    case 'li':\r\n      element = angular.element('<li></li>');\r\n      break;\r\n    default:\r\n      element = angular.element('<div></div>');\r\n  }\r\n  return element;\r\n}\r\n\r\nclass Padding {\r\n  constructor(template) {\r\n    this.element = generateElement(template);\r\n    this.cache = new Cache();\r\n  }\r\n\r\n  height() {\r\n    return this.element.height.apply(this.element, arguments);\r\n  }\r\n}\r\n\r\nexport default Padding;","import Padding from './padding';\r\n\r\nexport default function Viewport(elementRoutines, buffer, element, viewportController, $rootScope, padding) {\r\n  let topPadding = null;\r\n  let bottomPadding = null;\r\n  const viewport = viewportController && viewportController.viewport ? viewportController.viewport : angular.element(window);\r\n  const container = viewportController && viewportController.container ? viewportController.container : undefined;\r\n  const scope = viewportController && viewportController.scope ? viewportController.scope : $rootScope;\r\n\r\n  viewport.css({\r\n    'overflow-anchor': 'none',\r\n    'overflow-y': 'auto',\r\n    'display': 'block'\r\n  });\r\n\r\n  function bufferPadding() {\r\n    return viewport.outerHeight() * padding; // some extra space to initiate preload\r\n  }\r\n\r\n  angular.extend(viewport, {\r\n    getScope() {\r\n      return scope;\r\n    },\r\n\r\n    createPaddingElements(template) {\r\n      topPadding = new Padding(template);\r\n      bottomPadding = new Padding(template);\r\n      element.before(topPadding.element);\r\n      element.after(bottomPadding.element);\r\n      topPadding.height(0);\r\n      bottomPadding.height(0);\r\n    },\r\n\r\n    applyContainerStyle() {\r\n      if (!container) {\r\n        return true;\r\n      }\r\n      if (container !== viewport) {\r\n        viewport.css('height', window.getComputedStyle(container[0]).height);\r\n      }\r\n      return viewport.height() > 0;\r\n    },\r\n\r\n    bottomDataPos() {\r\n      let scrollHeight = viewport[0].scrollHeight;\r\n      scrollHeight = scrollHeight != null ? scrollHeight : viewport[0].document.documentElement.scrollHeight;\r\n      return scrollHeight - bottomPadding.height();\r\n    },\r\n\r\n    topDataPos() {\r\n      return topPadding.height();\r\n    },\r\n\r\n    bottomVisiblePos() {\r\n      return viewport.scrollTop() + viewport.outerHeight();\r\n    },\r\n\r\n    topVisiblePos() {\r\n      return viewport.scrollTop();\r\n    },\r\n\r\n    insertElement(e, sibling) {\r\n      return elementRoutines.insertElement(e, sibling || topPadding.element);\r\n    },\r\n\r\n    insertElementAnimated(e, sibling) {\r\n      return elementRoutines.insertElementAnimated(e, sibling || topPadding.element);\r\n    },\r\n\r\n    shouldLoadBottom() {\r\n      return !buffer.eof && viewport.bottomDataPos() < viewport.bottomVisiblePos() + bufferPadding();\r\n    },\r\n\r\n    clipBottom() {\r\n      // clip the invisible items off the bottom\r\n      let overage = 0;\r\n      let overageHeight = 0;\r\n      let itemHeight = 0;\r\n      let emptySpaceHeight = viewport.bottomDataPos() - viewport.bottomVisiblePos() - bufferPadding();\r\n\r\n      for (let i = buffer.length - 1; i >= 0; i--) {\r\n        itemHeight = buffer[i].element.outerHeight(true);\r\n        if (overageHeight + itemHeight > emptySpaceHeight) {\r\n          break;\r\n        }\r\n        bottomPadding.cache.add(buffer[i]);\r\n        overageHeight += itemHeight;\r\n        overage++;\r\n      }\r\n\r\n      if (overage > 0) {\r\n        buffer.eof = false;\r\n        buffer.remove(buffer.length - overage, buffer.length);\r\n        buffer.next -= overage;\r\n        viewport.adjustPaddings();\r\n      }\r\n    },\r\n\r\n    shouldLoadTop() {\r\n      return !buffer.bof && (viewport.topDataPos() > viewport.topVisiblePos() - bufferPadding());\r\n    },\r\n\r\n    clipTop() {\r\n      // clip the invisible items off the top\r\n      let overage = 0;\r\n      let overageHeight = 0;\r\n      let itemHeight = 0;\r\n      let emptySpaceHeight = viewport.topVisiblePos() - viewport.topDataPos() - bufferPadding();\r\n\r\n      for (let i = 0; i < buffer.length; i++) {\r\n        itemHeight = buffer[i].element.outerHeight(true);\r\n        if (overageHeight + itemHeight > emptySpaceHeight) {\r\n          break;\r\n        }\r\n        topPadding.cache.add(buffer[i]);\r\n        overageHeight += itemHeight;\r\n        overage++;\r\n      }\r\n\r\n      if (overage > 0) {\r\n        // we need to adjust top padding element before items are removed from top\r\n        // to avoid strange behaviour of scroll bar during remove top items when we are at the very bottom\r\n        topPadding.height(topPadding.height() + overageHeight);\r\n        buffer.bof = false;\r\n        buffer.remove(0, overage);\r\n        buffer.first += overage;\r\n      }\r\n    },\r\n\r\n    adjustPaddings() {\r\n      if (!buffer.length) {\r\n        return;\r\n      }\r\n\r\n      // precise heights calculation based on items that are in buffer or that were in buffer once\r\n      const visibleItemsHeight = buffer.reduce((summ, item) => summ + item.element.outerHeight(true), 0);\r\n\r\n      let topPaddingHeight = 0, topCount = 0;\r\n      topPadding.cache.forEach(item => {\r\n        if (item.index < buffer.first) {\r\n          topPaddingHeight += item.height;\r\n          topCount++;\r\n        }\r\n      });\r\n\r\n      let bottomPaddingHeight = 0, bottomCount = 0;\r\n      bottomPadding.cache.forEach(item => {\r\n        if (item.index >= buffer.next) {\r\n          bottomPaddingHeight += item.height;\r\n          bottomCount++;\r\n        }\r\n      });\r\n\r\n      const totalHeight = visibleItemsHeight + topPaddingHeight + bottomPaddingHeight;\r\n      const averageItemHeight = totalHeight / (topCount + bottomCount + buffer.length);\r\n\r\n      // average heights calculation, items that have never been reached\r\n      let adjustTopPadding = buffer.minIndexUser !== null && buffer.minIndex > buffer.minIndexUser;\r\n      let adjustBottomPadding = buffer.maxIndexUser !== null && buffer.maxIndex < buffer.maxIndexUser;\r\n      let topPaddingHeightAdd = adjustTopPadding ? (buffer.minIndex - buffer.minIndexUser) * averageItemHeight : 0;\r\n      let bottomPaddingHeightAdd = adjustBottomPadding ? (buffer.maxIndexUser - buffer.maxIndex) * averageItemHeight : 0;\r\n\r\n      // paddings combine adjustment\r\n      topPadding.height(topPaddingHeight + topPaddingHeightAdd);\r\n      bottomPadding.height(bottomPaddingHeight + bottomPaddingHeightAdd);\r\n    },\r\n\r\n    onAfterMinIndexSet(topPaddingHeightOld) {\r\n      // additional scrollTop adjustment in case of datasource.minIndex external set\r\n      if (buffer.minIndexUser !== null && buffer.minIndex > buffer.minIndexUser) {\r\n        let diff = topPadding.height() - topPaddingHeightOld;\r\n        viewport.scrollTop(viewport.scrollTop() + diff);\r\n        while((diff -= viewport.scrollTop()) > 0) {\r\n          bottomPadding.height(bottomPadding.height() + diff);\r\n          viewport.scrollTop(viewport.scrollTop() + diff);\r\n        }\r\n      }\r\n    },\r\n\r\n    onAfterPrepend(updates) {\r\n      if (!updates.prepended.length) {\r\n        return;\r\n      }\r\n      const height = buffer.effectiveHeight(updates.prepended);\r\n      const paddingHeight = topPadding.height() - height;\r\n      if (paddingHeight >= 0) {\r\n        topPadding.height(paddingHeight);\r\n        return;\r\n      }\r\n      const position = viewport.scrollTop();\r\n      const newPosition = position - paddingHeight;\r\n      viewport.synthetic = { previous: position, next: newPosition };\r\n      topPadding.height(0);\r\n      viewport.scrollTop(newPosition);\r\n    },\r\n\r\n    resetTopPadding() {\r\n      topPadding.height(0);\r\n      topPadding.cache.clear();\r\n    },\r\n\r\n    resetBottomPadding() {\r\n      bottomPadding.height(0);\r\n      bottomPadding.cache.clear();\r\n    },\r\n\r\n    removeCacheItem(item, shiftTop) {\r\n      topPadding.cache.remove(item, shiftTop);\r\n      bottomPadding.cache.remove(item, shiftTop);\r\n    },\r\n\r\n    removeItem(item) {\r\n      this.removeCacheItem(item);\r\n      return buffer.remove(item);\r\n    }\r\n  });\r\n\r\n  return viewport;\r\n}\r\n","import { OPERATIONS } from './utils';\r\n\r\nclass Adapter {\r\n\r\n  constructor($scope, $parse, $attr, viewport, buffer, doAdjust, reload) {\r\n    this.$parse = $parse;\r\n    this.$attr = $attr;\r\n    this.viewport = viewport;\r\n    this.buffer = buffer;\r\n\r\n    this.doAdjust = doAdjust;\r\n    this.reload = reload;\r\n\r\n    this.isLoading = false;\r\n    this.disabled = false;\r\n\r\n    const viewportScope = viewport.getScope();\r\n    this.startScope = viewportScope.$parent ? viewportScope : $scope;\r\n\r\n    this.publicContext = {};\r\n    this.assignAdapter($attr.adapter);\r\n    this.generatePublicContext();\r\n  }\r\n\r\n  assignAdapter(adapterAttr) {\r\n    if (!adapterAttr || !(adapterAttr = adapterAttr.replace(/^\\s+|\\s+$/gm, ''))) {\r\n      return;\r\n    }\r\n    let adapterOnScope;\r\n\r\n    try {\r\n      this.$parse(adapterAttr).assign(this.startScope, {});\r\n      adapterOnScope = this.$parse(adapterAttr)(this.startScope);\r\n    }\r\n    catch (error) {\r\n      error.message = `Angular ui-scroll Adapter assignment exception.\\n` +\r\n        `Can't parse \"${adapterAttr}\" expression.\\n` +\r\n        error.message;\r\n      throw error;\r\n    }\r\n\r\n    angular.extend(adapterOnScope, this.publicContext);\r\n    this.publicContext = adapterOnScope;\r\n  }\r\n\r\n  generatePublicContext() {\r\n    // these methods will be accessible out of ui-scroll via user defined adapter\r\n    const publicMethods = ['reload', 'applyUpdates', 'append', 'prepend', 'isBOF', 'isEOF', 'isEmpty'];\r\n    for (let i = publicMethods.length - 1; i >= 0; i--) {\r\n      this.publicContext[publicMethods[i]] = this[publicMethods[i]].bind(this);\r\n    }\r\n\r\n    // these read-only props will be accessible out of ui-scroll via user defined adapter\r\n    const publicProps = ['isLoading', 'topVisible', 'topVisibleElement', 'topVisibleScope', 'bottomVisible', 'bottomVisibleElement', 'bottomVisibleScope'];\r\n    for (let i = publicProps.length - 1; i >= 0; i--) {\r\n      let property, attr = this.$attr[publicProps[i]];\r\n      Object.defineProperty(this, publicProps[i], {\r\n        get: () => property,\r\n        set: (value) => {\r\n          property = value;\r\n          this.publicContext[publicProps[i]] = value;\r\n          if (attr) {\r\n            this.$parse(attr).assign(this.startScope, value);\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    // read-only immediately calculated public properties\r\n    const publicPropsImmediate = ['bufferFirst', 'bufferLast', 'bufferLength'];\r\n    for (let i = publicPropsImmediate.length - 1; i >= 0; i--) {\r\n      Object.defineProperty(this.publicContext, publicPropsImmediate[i], {\r\n        get: () => this[publicPropsImmediate[i]]\r\n      });\r\n    }\r\n\r\n    // non-read-only public property\r\n    Object.defineProperty(this.publicContext, 'disabled', {\r\n      get: () => this.disabled,\r\n      set: (value) => (!(this.disabled = value)) ? this.doAdjust() : null\r\n    });\r\n  }\r\n\r\n  loading(value) {\r\n    this.isLoading = value;\r\n  }\r\n\r\n  isBOF() {\r\n    return this.buffer.bof;\r\n  }\r\n\r\n  isEOF() {\r\n    return this.buffer.eof;\r\n  }\r\n\r\n  isEmpty() {\r\n    return !this.buffer.length;\r\n  }\r\n\r\n  get bufferLength() {\r\n    return this.buffer.getItems().length;\r\n  }\r\n\r\n  get bufferFirst() {\r\n    return this.buffer.getFirstItem();\r\n  }\r\n\r\n  get bufferLast() {\r\n    return this.buffer.getLastItem();\r\n  }\r\n\r\n  append(newItems) {\r\n    this.buffer.append(newItems);\r\n    this.doAdjust();\r\n    this.viewport.clipTop();\r\n    this.viewport.clipBottom();\r\n  }\r\n\r\n  prepend(newItems, options = {}) {\r\n    this.buffer.prepend(newItems, options.immutableTop);\r\n    this.doAdjust();\r\n    this.viewport.clipTop();\r\n    this.viewport.clipBottom();\r\n  }\r\n\r\n  applyUpdates(arg1, arg2, arg3) {\r\n    if (typeof arg1 === 'function') {\r\n      this.applyUpdatesFunc(arg1, arg2);\r\n    } else {\r\n      this.applyUpdatesIndex(arg1, arg2, arg3);\r\n    }\r\n    this.doAdjust();\r\n  }\r\n\r\n  applyUpdatesFunc(cb, options = {}) {\r\n    this.buffer.slice(0).forEach((wrapper) => {\r\n      // we need to do it on the buffer clone, because buffer content\r\n      // may change as we iterate through\r\n      this.applyUpdate(wrapper, cb(wrapper.item, wrapper.scope, wrapper.element), options);\r\n    });\r\n  }\r\n\r\n  applyUpdatesIndex(index, newItems, options = {}) {\r\n    if (index % 1 !== 0) {\r\n      throw new Error('applyUpdates - ' + index + ' is not a valid index (should be an integer)');\r\n    }\r\n    const _index = index - this.buffer.first;\r\n\r\n    // apply updates only within buffer\r\n    if (_index >= 0 && _index < this.buffer.length) {\r\n      this.applyUpdate(this.buffer[_index], newItems, options);\r\n    }\r\n    // out-of-buffer case: deletion may affect Paddings\r\n    else if(index >= this.buffer.getAbsMinIndex() && index <= this.buffer.getAbsMaxIndex()) {\r\n      if(angular.isArray(newItems) && !newItems.length) {\r\n        this.viewport.removeCacheItem(index, !options.immutableTop && index === this.buffer.minIndex);\r\n        if (!options.immutableTop && index === this.buffer.getAbsMinIndex()) {\r\n          this.buffer.incrementMinIndex();\r\n        }\r\n        else {\r\n          this.buffer.decrementMaxIndex();\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  applyUpdate(wrapper, newItems, options = {}) {\r\n    if (!angular.isArray(newItems)) {\r\n      return;\r\n    }\r\n    let position = this.buffer.indexOf(wrapper);\r\n    if (!newItems.reverse().some(newItem => newItem === wrapper.item)) {\r\n      wrapper.op = OPERATIONS.REMOVE;\r\n      // try to catch \"first\" edge case on remove\r\n      if (!options.immutableTop && !newItems.length) {\r\n        // this is the first item, or the previous one's part of the \"shift-top\" group\r\n        if (\r\n          (position === 0 && this.buffer.bof) ||\r\n          (position !== 0 && this.buffer[position - 1].shiftTop)\r\n        ) {\r\n          wrapper.shiftTop = true;\r\n        }\r\n      }\r\n    }\r\n    newItems.forEach((newItem) => {\r\n      if (newItem === wrapper.item) {\r\n        position--;\r\n      } else {\r\n        // 3 parameter (shiftTop) is to catch \"first\" edge case on insert\r\n        this.buffer.insert(position + 1, newItem, !options.immutableTop && position === -1);\r\n      }\r\n    });\r\n  }\r\n\r\n  calculateProperties() {\r\n    let rowTop = null, topHeight = 0;\r\n    let topDone = false, bottomDone = false;\r\n    const length = this.buffer.length;\r\n\r\n    for (let i = 0; i < length; i++) {\r\n      const item = this.buffer[i];\r\n      const itemTop = item.element.offset().top;\r\n\r\n      if (rowTop !== itemTop) { // a new row condition\r\n        const itemHeight = item.element.outerHeight(true);\r\n        const top = this.viewport.topDataPos() + topHeight + itemHeight;\r\n\r\n        if (!topDone && top > this.viewport.topVisiblePos()) {\r\n          topDone = true;\r\n          this['topVisible'] = item.item;\r\n          this['topVisibleElement'] = item.element;\r\n          this['topVisibleScope'] = item.scope;\r\n        }\r\n        if (!bottomDone && (top >= this.viewport.bottomVisiblePos() || (i === length - 1 && this.isEOF()))) {\r\n          bottomDone = true;\r\n          this['bottomVisible'] = item.item;\r\n          this['bottomVisibleElement'] = item.element;\r\n          this['bottomVisibleScope'] = item.scope;\r\n        }\r\n        topHeight += itemHeight;\r\n      }\r\n      rowTop = itemTop;\r\n\r\n      if (topDone && bottomDone) {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport default Adapter;\r\n","import JQLiteExtras from './modules/jqLiteExtras';\r\nimport ElementRoutines from './modules/elementRoutines.js';\r\nimport ScrollBuffer from './modules/buffer.js';\r\nimport Viewport from './modules/viewport.js';\r\nimport Adapter from './modules/adapter.js';\r\nimport { OPERATIONS } from './modules/utils';\r\n\r\nangular.module('ui.scroll', [])\r\n\r\n  .constant('JQLiteExtras', JQLiteExtras)\r\n  .run(['JQLiteExtras', (JQLiteExtras) => {\r\n    const elt = angular.element;\r\n    !(window.jQuery && elt.fn && elt.fn.jquery) ? (new JQLiteExtras()).registerFor(elt) : null;\r\n    ElementRoutines.addCSSRules();\r\n  }])\r\n\r\n  .directive('uiScrollViewport', function () {\r\n    return {\r\n      restrict: 'A',\r\n      controller: [\r\n        '$scope',\r\n        '$element',\r\n        function (scope, element) {\r\n          this.container = element;\r\n          this.viewport = element;\r\n          this.scope = scope;\r\n\r\n          angular.forEach(element.children(), child => {\r\n            if (child.tagName.toLowerCase() === 'tbody') {\r\n              this.viewport = angular.element(child);\r\n            }\r\n          });\r\n\r\n          return this;\r\n        }\r\n      ]\r\n    };\r\n  })\r\n\r\n  .directive('uiScroll', [\r\n    '$log',\r\n    '$injector',\r\n    '$rootScope',\r\n    '$timeout',\r\n    '$interval',\r\n    '$q',\r\n    '$parse',\r\n    function (console, $injector, $rootScope, $timeout, $interval, $q, $parse) {\r\n\r\n      return {\r\n        require: ['?^uiScrollViewport'],\r\n        restrict: 'A',\r\n        transclude: 'element',\r\n        priority: 1000,\r\n        terminal: true,\r\n        link: link\r\n      };\r\n\r\n      function link($scope, element, $attr, controllers, linker) {\r\n        const match = $attr.uiScroll.match(/^\\s*(\\w+)\\s+in\\s+([(\\w|\\$)\\.]+)\\s*$/);\r\n        if (!match) {\r\n          throw new Error('Expected uiScroll in form of \\'_item_ in _datasource_\\' but got \\'' + $attr.uiScroll + '\\'');\r\n        }\r\n\r\n        function parseNumber(value, defaultValue, isFloat) {\r\n          if (!isFloat) {\r\n            value = value === null ? defaultValue : Math.floor(value);\r\n          }\r\n          return isNaN(value) ? defaultValue : value;\r\n        }\r\n\r\n        function parseNumericAttr(value, defaultValue, isFloat) {\r\n          const result = $parse(value)($scope);\r\n          return parseNumber(result, defaultValue, isFloat);\r\n        }\r\n\r\n        function parseBooleanAttr(value, defaultValue) {\r\n          const result = $parse(value)($scope);\r\n          return typeof result === 'boolean' ? result : defaultValue;\r\n        }\r\n\r\n        const BUFFER_MIN = 3;\r\n        const BUFFER_DEFAULT = 10;\r\n        const PADDING_MIN = 0.3;\r\n        const PADDING_DEFAULT = 0.5;\r\n        const HANDLE_INERTIA_DEFAULT = true;\r\n        const START_INDEX_DEFAULT = 1;\r\n        const MAX_VIEWPORT_DELAY = 500;\r\n        const VIEWPORT_POLLING_INTERVAL = 50;\r\n\r\n        let datasource = null;\r\n        const itemName = match[1];\r\n        const datasourceName = match[2];\r\n        const viewportController = controllers[0];\r\n        const bufferSize = Math.max(BUFFER_MIN, parseNumericAttr($attr.bufferSize, BUFFER_DEFAULT));\r\n        const padding = Math.max(PADDING_MIN, parseNumericAttr($attr.padding, PADDING_DEFAULT, true));\r\n        const handleInertia = parseBooleanAttr($attr.handleInertia, HANDLE_INERTIA_DEFAULT);\r\n        let startIndex = parseNumericAttr($attr.startIndex, START_INDEX_DEFAULT);\r\n        let ridActual = 0; // current data revision id\r\n        let pending = [];\r\n\r\n        const elementRoutines = new ElementRoutines($injector, $q);\r\n        const buffer = new ScrollBuffer(elementRoutines, bufferSize, startIndex);\r\n        const viewport = new Viewport(elementRoutines, buffer, element, viewportController, $rootScope, padding);\r\n        const adapter = new Adapter($scope, $parse, $attr, viewport, buffer, doAdjust, reload);\r\n\r\n        if (viewportController) {\r\n          viewportController.adapter = adapter;\r\n        }\r\n\r\n        const isDatasourceValid = () =>\r\n          Object.prototype.toString.call(datasource) === '[object Object]' && typeof datasource.get === 'function';\r\n\r\n        datasource = $parse(datasourceName)($scope); // try to get datasource on scope\r\n        if (!isDatasourceValid()) {\r\n          datasource = $injector.get(datasourceName); // try to inject datasource as service\r\n          if (!isDatasourceValid()) {\r\n            throw new Error(datasourceName + ' is not a valid datasource');\r\n          }\r\n        }\r\n\r\n        let onRenderHandlers = [];\r\n        function onRenderHandlersRunner() {\r\n          onRenderHandlers.forEach(handler => handler.run());\r\n          onRenderHandlers = [];\r\n        }\r\n        function persistDatasourceIndex(datasource, propName) {\r\n          let getter;\r\n          // need to postpone min/maxIndexUser processing if the view is empty\r\n          if(angular.isNumber(datasource[propName])) {\r\n            getter = datasource[propName];\r\n            if(angular.isNumber(getter)) {\r\n              onRenderHandlers = onRenderHandlers.filter(handler => handler.id !== propName);\r\n              onRenderHandlers.push({\r\n                id: propName,\r\n                run: () => datasource[propName] = getter\r\n              });\r\n            }\r\n          }\r\n        }\r\n\r\n        function defineDatasourceIndex(datasource, propName, propUserName) {\r\n          const descriptor = Object.getOwnPropertyDescriptor(datasource, propName);\r\n          if (descriptor && (descriptor.set || descriptor.get)) {\r\n            return;\r\n          }\r\n          let getter;\r\n          persistDatasourceIndex(datasource, propName);\r\n          Object.defineProperty(datasource, propName, {\r\n            set: (value) => {\r\n              getter = value;\r\n              if(pending.length && !buffer.length) {\r\n                persistDatasourceIndex(datasource, propName);\r\n                return;\r\n              }\r\n              buffer[propUserName] = value;\r\n              const topPaddingHeightOld = viewport.topDataPos();\r\n              viewport.adjustPaddings();\r\n              if (propName === 'minIndex') {\r\n                viewport.onAfterMinIndexSet(topPaddingHeightOld);\r\n              }\r\n            },\r\n            get: () => getter\r\n          });\r\n        }\r\n\r\n        defineDatasourceIndex(datasource, 'minIndex', 'minIndexUser');\r\n        defineDatasourceIndex(datasource, 'maxIndex', 'maxIndexUser');\r\n\r\n        const fetchNext = (datasource.get.length !== 2) ?\r\n          (success) => datasource.get(buffer.next, bufferSize, success) :\r\n          (success) => {\r\n            datasource.get({\r\n              index: buffer.next,\r\n              append: buffer.length ? buffer[buffer.length - 1].item : void 0,\r\n              count: bufferSize\r\n            }, success);\r\n          };\r\n\r\n        const fetchPrevious = (datasource.get.length !== 2) ?\r\n          (success) => datasource.get(buffer.first - bufferSize, bufferSize, success) :\r\n          (success) => {\r\n            datasource.get({\r\n              index: buffer.first - bufferSize,\r\n              prepend: buffer.length ? buffer[0].item : void 0,\r\n              count: bufferSize\r\n            }, success);\r\n          };\r\n\r\n        const initialize = () => {\r\n          let tryCount = 0;\r\n          if(!viewport.applyContainerStyle()) {\r\n            const timer = $interval(() => {\r\n              tryCount++;\r\n              if(viewport.applyContainerStyle()) {\r\n                $interval.cancel(timer);\r\n                doAdjust();\r\n              }\r\n              if(tryCount * VIEWPORT_POLLING_INTERVAL >= MAX_VIEWPORT_DELAY) {\r\n                $interval.cancel(timer);\r\n                throw Error(`ui-scroll directive requires a viewport with non-zero height in ${MAX_VIEWPORT_DELAY}ms`);\r\n              }\r\n            }, VIEWPORT_POLLING_INTERVAL);\r\n          }\r\n          else {\r\n            doAdjust();\r\n          }\r\n        };\r\n\r\n        /**\r\n         * Build padding elements\r\n         *\r\n         * Calling linker is the only way I found to get access to the tag name of the template\r\n         * to prevent the directive scope from pollution a new scope is created and destroyed\r\n         * right after the builder creation is completed\r\n         */\r\n        linker((clone, scope) => {\r\n          viewport.createPaddingElements(clone[0]);\r\n          // we do not include the clone in the DOM. It means that the nested directives will not\r\n          // be able to reach the parent directives, but in this case it is intentional because we\r\n          // created the clone to access the template tag name\r\n          scope.$destroy();\r\n          clone.remove();\r\n        });\r\n\r\n        $scope.$on('$destroy', () => {\r\n          unbindEvents();\r\n          viewport.off('mousewheel', wheelHandler);\r\n        });\r\n\r\n        viewport.on('mousewheel', wheelHandler);\r\n\r\n        initialize();\r\n\r\n        /* Private function definitions */\r\n\r\n        function isInvalid(rid) {\r\n          return (rid && rid !== ridActual) || $scope.$$destroyed;\r\n        }\r\n\r\n        function bindEvents() {\r\n          viewport.on('resize', resizeAndScrollHandler);\r\n          viewport.on('scroll', resizeAndScrollHandler);\r\n        }\r\n\r\n        function unbindEvents() {\r\n          viewport.off('resize', resizeAndScrollHandler);\r\n          viewport.off('scroll', resizeAndScrollHandler);\r\n        }\r\n\r\n        function reload() {\r\n          unbindEvents();\r\n          viewport.resetTopPadding();\r\n          viewport.resetBottomPadding();\r\n          if (arguments.length) {\r\n            startIndex = parseNumber(arguments[0], START_INDEX_DEFAULT, false);\r\n          }\r\n          buffer.reset(startIndex);\r\n          persistDatasourceIndex(datasource, 'minIndex');\r\n          persistDatasourceIndex(datasource, 'maxIndex');\r\n          doAdjust();\r\n        }\r\n\r\n        function isElementVisible(wrapper) {\r\n          return wrapper.element.height() && wrapper.element[0].offsetParent;\r\n        }\r\n\r\n        function visibilityWatcher(wrapper) {\r\n          if (isElementVisible(wrapper)) {\r\n            buffer.forEach((item) => {\r\n              if (typeof item.unregisterVisibilityWatcher === 'function') {\r\n                item.unregisterVisibilityWatcher();\r\n                delete item.unregisterVisibilityWatcher;\r\n              }\r\n            });\r\n            if (!pending.length) {\r\n              $timeout(() => doAdjust());\r\n            }\r\n          }\r\n        }\r\n\r\n        function insertWrapperContent(wrapper, insertAfter) {\r\n          createElement(wrapper, insertAfter, viewport.insertElement);\r\n          if (!isElementVisible(wrapper)) {\r\n            wrapper.unregisterVisibilityWatcher = wrapper.scope.$watch(() => visibilityWatcher(wrapper));\r\n          }\r\n          elementRoutines.hideElement(wrapper); // hide inserted elements before data binding\r\n        }\r\n\r\n        function createElement(wrapper, insertAfter, insertElement) {\r\n          let promises = null;\r\n          const sibling = (insertAfter > 0) ? buffer[insertAfter - 1].element : undefined;\r\n          linker((clone, scope) => {\r\n            promises = insertElement(clone, sibling);\r\n            wrapper.element = clone;\r\n            wrapper.scope = scope;\r\n            scope[itemName] = wrapper.item;\r\n          });\r\n          // ui-scroll-grid apply\r\n          if (adapter.transform) {\r\n            const tdInitializer = wrapper.scope.uiScrollTdInitializer;\r\n            if (tdInitializer && tdInitializer.linking) {\r\n              adapter.transform(wrapper.scope, wrapper.element);\r\n            } else {\r\n              wrapper.scope.uiScrollTdInitializer = {\r\n                onLink: () => adapter.transform(wrapper.scope, wrapper.element),\r\n                scope: wrapper.scope\r\n              };\r\n            }\r\n          }\r\n          return promises;\r\n        }\r\n\r\n        function updateDOM() {\r\n          let promises = [];\r\n          const toBePrepended = [];\r\n          const toBeRemoved = [];\r\n          const inserted = [];\r\n\r\n          buffer.forEach((wrapper, i) => {\r\n            switch (wrapper.op) {\r\n              case OPERATIONS.PREPEND:\r\n                toBePrepended.unshift(wrapper);\r\n                break;\r\n              case OPERATIONS.APPEND:\r\n                insertWrapperContent(wrapper, i);\r\n                wrapper.op = OPERATIONS.NONE;\r\n                inserted.push(wrapper);\r\n                break;\r\n              case OPERATIONS.INSERT:\r\n                promises = promises.concat(createElement(wrapper, i, viewport.insertElementAnimated));\r\n                wrapper.op = OPERATIONS.NONE;\r\n                inserted.push(wrapper);\r\n                break;\r\n              case OPERATIONS.REMOVE:\r\n                toBeRemoved.push(wrapper);\r\n            }\r\n          });\r\n\r\n          toBeRemoved.forEach((wrapper) => promises = promises.concat(viewport.removeItem(wrapper)));\r\n\r\n          if (toBePrepended.length)\r\n            toBePrepended.forEach((wrapper) => {\r\n              insertWrapperContent(wrapper);\r\n              wrapper.op = OPERATIONS.NONE;\r\n            });\r\n\r\n          buffer.forEach((item, i) => item.scope.$index = buffer.first + i);\r\n\r\n          return {\r\n            prepended: toBePrepended,\r\n            removed: toBeRemoved,\r\n            inserted: inserted,\r\n            animated: promises\r\n          };\r\n\r\n        }\r\n\r\n        function updatePaddings(rid, updates) {\r\n          // schedule another doAdjust after animation completion\r\n          if (updates.animated.length) {\r\n            $q.all(updates.animated).then(() => {\r\n              viewport.adjustPaddings();\r\n              doAdjust(rid);\r\n            });\r\n          } else {\r\n            viewport.adjustPaddings();\r\n          }\r\n        }\r\n\r\n        function enqueueFetch(rid, updates) {\r\n          if (viewport.shouldLoadBottom()) {\r\n            if (!updates || buffer.effectiveHeight(updates.inserted) > 0) {\r\n              // this means that at least one item appended in the last batch has height > 0\r\n              if (pending.push(true) === 1) {\r\n                adapter.loading(true);\r\n                fetch(rid);\r\n              }\r\n            }\r\n          } else if (viewport.shouldLoadTop()) {\r\n            if ((!updates || buffer.effectiveHeight(updates.prepended) > 0) || pending[0]) {\r\n              // this means that at least one item appended in the last batch has height > 0\r\n              // pending[0] = true means that previous fetch was appending. We need to force at least one prepend\r\n              // BTW there will always be at least 1 element in the pending array because bottom is fetched first\r\n              if (pending.push(false) === 1) {\r\n                adapter.loading(true);\r\n                fetch(rid);\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        function processUpdates() {\r\n          const updates = updateDOM();\r\n\r\n          // We need the item bindings to be processed before we can do adjustments\r\n          !$scope.$$phase && !$rootScope.$$phase && $scope.$digest();\r\n\r\n          updates.inserted.forEach(w => elementRoutines.showElement(w));\r\n          updates.prepended.forEach(w => elementRoutines.showElement(w));\r\n          return updates;\r\n        }\r\n\r\n        function doAdjust(rid) {\r\n          if (!rid) { // dismiss pending requests\r\n            pending = [];\r\n            rid = ++ridActual;\r\n          }\r\n\r\n          const updates = processUpdates();\r\n\r\n          if (isInvalid(rid)) {\r\n            return;\r\n          }\r\n\r\n          updatePaddings(rid, updates);\r\n          enqueueFetch(rid);\r\n\r\n          if (!pending.length) {\r\n            adapter.calculateProperties();\r\n          }\r\n        }\r\n\r\n        function doAdjustAfterFetch(rid) {\r\n          const updates = processUpdates();\r\n\r\n          viewport.onAfterPrepend(updates);\r\n\r\n          if (isInvalid(rid)) {\r\n            return;\r\n          }\r\n\r\n          updatePaddings(rid, updates);\r\n          onRenderHandlersRunner();\r\n          enqueueFetch(rid, updates);\r\n          pending.shift();\r\n\r\n          if (pending.length)\r\n            fetch(rid);\r\n          else {\r\n            adapter.loading(false);\r\n            bindEvents();\r\n            adapter.calculateProperties();\r\n          }\r\n        }\r\n\r\n        function fetch(rid) {\r\n          if (pending[0]) {// scrolling down\r\n            if (buffer.length && !viewport.shouldLoadBottom()) {\r\n              doAdjustAfterFetch(rid);\r\n            } else {\r\n              fetchNext((result) => {\r\n                if (isInvalid(rid)) {\r\n                  return;\r\n                }\r\n\r\n                if (result.length < bufferSize) {\r\n                  buffer.eof = true;\r\n                }\r\n\r\n                if (result.length > 0) {\r\n                  viewport.clipTop();\r\n                  buffer.append(result);\r\n                }\r\n\r\n                doAdjustAfterFetch(rid);\r\n              });\r\n            }\r\n          } else {  // scrolling up\r\n            if (buffer.length && !viewport.shouldLoadTop()) {\r\n              doAdjustAfterFetch(rid);\r\n            } else {\r\n              fetchPrevious((result) => {\r\n                if (isInvalid(rid)) {\r\n                  return;\r\n                }\r\n\r\n                if (result.length < bufferSize) {\r\n                  buffer.bof = true;\r\n                  // log 'bof is reached'\r\n                }\r\n\r\n                if (result.length > 0) {\r\n                  if (buffer.length) {\r\n                    viewport.clipBottom();\r\n                  }\r\n                  buffer.prepend(result);\r\n                }\r\n\r\n                doAdjustAfterFetch(rid);\r\n              });\r\n            }\r\n          }\r\n        }\r\n\r\n        function fixInertia() {\r\n          if (!viewport.synthetic) {\r\n            return;\r\n          }\r\n          const oldPosition = viewport.synthetic.previous;\r\n          const newPosition = viewport.synthetic.next;\r\n          if (viewport.scrollTop() !== newPosition) {\r\n            requestAnimationFrame(() => {\r\n              const position = viewport.scrollTop();\r\n              const diff = oldPosition - position;\r\n              if (diff > 0) { // inertia over synthetic\r\n                viewport.scrollTop(newPosition - diff);\r\n              } else {\r\n                viewport.scrollTop(newPosition);\r\n              }\r\n              viewport.synthetic = null;\r\n            });\r\n            return true;\r\n          }\r\n          viewport.synthetic = null;\r\n        }\r\n\r\n        function resizeAndScrollHandler() {\r\n          if (handleInertia && fixInertia()) {\r\n            return;\r\n          }\r\n          if (!$rootScope.$$phase && !adapter.isLoading && !adapter.disabled) {\r\n\r\n            enqueueFetch(ridActual);\r\n\r\n            if (pending.length) {\r\n              unbindEvents();\r\n            } else {\r\n              adapter.calculateProperties();\r\n              !$scope.$$phase && $scope.$digest();\r\n            }\r\n          }\r\n        }\r\n\r\n        function wheelHandler(event) {\r\n          if (!adapter.disabled) {\r\n            const scrollTop = viewport[0].scrollTop;\r\n            const yMax = viewport[0].scrollHeight - viewport[0].clientHeight;\r\n\r\n            if ((scrollTop === 0 && !buffer.bof) || (scrollTop === yMax && !buffer.eof)) {\r\n              event.preventDefault();\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n    }\r\n  ]);\r\n"],"names":["JQLiteExtras","_classCallCheck","key","value","element","convertToPx","css","getStyle","isWindow","scrollTo","self","direction","elem","_top$left$direction","_slicedToArray","top","left","method","prop","preserve","isValueDefined","call","document","documentElement","getWidthHeight","measure","result","measurements","base","borderA","borderB","computedMarginA","computedMarginB","computedStyle","dirA","dirB","paddingA","paddingB","height","width","padding","border","margin","_width$height$measure","offsetWidth","offsetHeight","getMeasurements","outer","outerfull","style","parseFloat","angular","prototype","name","this","nodeType","obj","location","alert","setInterval","window","getComputedStyle","currentStyle","rs","rsLeft","RegExp","source","test","runtimeStyle","pixelLeft","forEach","before","newElem","children","i","j","parent","ref","contents","prepend","length","after","Error","outerHTML","isNumber","outerHeight","option","outerWidth","offset","docElem","win","box","doc","ownerDocument","arguments","undefined","getBoundingClientRect","defaultView","parentWindow","pageYOffset","scrollTop","clientTop","pageXOffset","scrollLeft","clientLeft","hideClassToken","ElementRoutines","$injector","$q","$animate","has","get","isAngularVersionLessThen1_3","version","major","minor","index","selector","rules","sheet","styleSheets","cssRules","err","insertRule","addRule","wrapper","addClass","removeClass","newElement","previousElement","remove","scope","$destroy","insertElement","deferred","defer","enter","resolve","promise","removeElement","leave","then","OPERATIONS","PREPEND","APPEND","INSERT","REMOVE","NONE","ScrollBuffer","elementRoutines","bufferSize","startIndex","buffer","Object","create","Array","extend","size","reset","eof","bof","first","next","minIndex","maxIndex","minIndexUser","maxIndexUser","append","items","item","insert","Math","max","immutableTop","reverse","min","operation","shiftTop","op","splice","push","unshift","arg1","arg2","indexOf","getAbsMinIndex","incrementMinIndex","decrementMaxIndex","removeElementAnimated","getAbsMaxIndex","effectiveHeight","elements","Number","MAX_VALUE","bottom","NEGATIVE_INFINITY","offsetParent","getItems","filter","getFirstItem","list","getLastItem","CacheProto","_createClass","$index","sort","a","b","argument","_shiftTop","Cache","instance","apply","setPrototypeOf","getOwnPropertyNames","methodName","Padding","template","Node","ELEMENT_NODE","tagName","toLowerCase","concat","find","generateElement","cache","Viewport","viewportController","$rootScope","topPadding","bottomPadding","viewport","container","bufferPadding","getScope","createPaddingElements","applyContainerStyle","bottomDataPos","scrollHeight","topDataPos","bottomVisiblePos","topVisiblePos","e","sibling","insertElementAnimated","shouldLoadBottom","clipBottom","overage","overageHeight","itemHeight","emptySpaceHeight","add","adjustPaddings","shouldLoadTop","clipTop","visibleItemsHeight","reduce","summ","topPaddingHeight","topCount","bottomPaddingHeight","bottomCount","averageItemHeight","adjustTopPadding","adjustBottomPadding","topPaddingHeightAdd","bottomPaddingHeightAdd","onAfterMinIndexSet","topPaddingHeightOld","diff","onAfterPrepend","updates","prepended","paddingHeight","position","newPosition","synthetic","previous","resetTopPadding","clear","resetBottomPadding","removeCacheItem","removeItem","Adapter","$scope","$parse","$attr","doAdjust","reload","isLoading","disabled","viewportScope","startScope","$parent","publicContext","assignAdapter","adapter","generatePublicContext","adapterAttr","replace","adapterOnScope","assign","error","message","_this","publicMethods","bind","publicProps","_loop","_i","property","attr","defineProperty","set","publicPropsImmediate","_loop2","_i2","newItems","options","arg3","applyUpdatesFunc","applyUpdatesIndex","cb","_this2","slice","applyUpdate","_index","isArray","_this3","some","newItem","rowTop","topHeight","topDone","bottomDone","itemTop","isEOF","module","constant","run","elt","jQuery","fn","jquery","registerFor","addCSSRules","directive","restrict","controller","child","console","$timeout","$interval","require","transclude","priority","terminal","link","controllers","linker","match","uiScroll","parseNumber","defaultValue","isFloat","floor","isNaN","parseNumericAttr","datasource","itemName","datasourceName","handleInertia","ridActual","pending","unbindEvents","persistDatasourceIndex","isDatasourceValid","toString","onRenderHandlers","propName","getter","handler","id","defineDatasourceIndex","propUserName","descriptor","getOwnPropertyDescriptor","fetchNext","success","count","fetchPrevious","isInvalid","rid","$$destroyed","off","resizeAndScrollHandler","isElementVisible","insertWrapperContent","insertAfter","createElement","unregisterVisibilityWatcher","$watch","visibilityWatcher","hideElement","promises","clone","transform","tdInitializer","uiScrollTdInitializer","linking","onLink","updatePaddings","animated","all","enqueueFetch","inserted","loading","fetch","processUpdates","toBePrepended","toBeRemoved","removed","$$phase","$digest","w","showElement","calculateProperties","doAdjustAfterFetch","shift","on","oldPosition","requestAnimationFrame","fixInertia","wheelHandler","event","yMax","clientHeight","preventDefault","$on","tryCount","timer","cancel","initialize"],"sourceRoot":""}