{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/modules/jqLiteExtras.js","webpack:///./src/modules/elementRoutines.js","webpack:///./src/modules/buffer.js","webpack:///./src/modules/padding.js","webpack:///./src/modules/viewport.js","webpack:///./src/modules/adapter.js","webpack:///./src/ui-scroll.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","JQLiteExtras","element","convertToPx","css","getStyle","isWindow","scrollTo","self","direction","elem","_top$left$direction","_slicedToArray","top","left","method","prop","preserve","isValueDefined","document","documentElement","getWidthHeight","measure","result","measurements","base","borderA","borderB","computedMarginA","computedMarginB","computedStyle","dirA","dirB","paddingA","paddingB","height","width","padding","border","margin","_width$height$measure","offsetWidth","offsetHeight","getMeasurements","outer","outerfull","style","parseFloat","angular","this","nodeType","obj","location","alert","setInterval","window","getComputedStyle","currentStyle","rs","rsLeft","RegExp","source","test","runtimeStyle","pixelLeft","forEach","before","newElem","children","j","parent","ref","contents","prepend","length","after","Error","outerHTML","isNumber","outerHeight","option","outerWidth","offset","docElem","win","box","doc","ownerDocument","arguments","undefined","getBoundingClientRect","defaultView","parentWindow","pageYOffset","scrollTop","clientTop","pageXOffset","scrollLeft","clientLeft","hideClassToken","ElementRoutines","$injector","$q","elementRoutines_classCallCheck","$animate","has","isAngularVersionLessThen1_3","version","major","minor","index","selector","rules","sheet","styleSheets","cssRules","err","insertRule","addRule","wrapper","addClass","removeClass","newElement","previousElement","remove","scope","$destroy","insertElement","deferred","defer","enter","resolve","promise","removeElement","leave","then","ScrollBuffer","elementRoutines","bufferSize","startIndex","rowHeight","buffer","Array","extend","size","reset","eof","bof","first","next","minIndex","maxIndex","minIndexUser","maxIndexUser","resetStartIndex","append","items","item","insert","Math","max","reverse","min","operation","isTop","op","splice","push","unshift","arg1","arg2","indexOf","_op","getAbsMinIndex","incrementMinIndex","decrementMaxIndex","removeElementAnimated","getAbsMaxIndex","effectiveHeight","elements","Number","MAX_VALUE","bottom","NEGATIVE_INFINITY","offsetParent","getItems","filter","getFirstItem","list","getLastItem","CacheProto","$index","sort","a","b","argument","_isTop","Cache","instance","apply","setPrototypeOf","getOwnPropertyNames","methodName","Padding","template","useCache","padding_classCallCheck","Node","ELEMENT_NODE","tagName","toLowerCase","concat","find","generateElement","cache","Viewport","viewportController","$rootScope","topPadding","bottomPadding","viewport","container","bufferPadding","overflow-anchor","overflow-y","display","getScope","createPaddingElements","applyContainerStyle","bottomDataPos","scrollHeight","topDataPos","bottomVisiblePos","topVisiblePos","e","sibling","insertElementAnimated","shouldLoadBottom","clipBottom","overage","emptySpaceHeight","floor","itemHeight","overageHeight","add","adjustPaddings","shouldLoadTop","clipTop","visibleItemsHeight","reduce","summ","topPaddingHeight","topCount","bottomPaddingHeight","bottomCount","averageItemHeight","adjustTopPadding","adjustBottomPadding","topPaddingHeightAdd","bottomPaddingHeightAdd","onAfterMinIndexSet","topPaddingHeightOld","diff","onAfterPrepend","updates","prepended","paddingHeight","resetTopPadding","clear","resetBottomPadding","removeCacheItem","removeItem","Adapter","$scope","$parse","$attr","doAdjust","reload","adapter_classCallCheck","isLoading","disabled","viewportScope","startScope","$parent","publicContext","assignAdapter","adapter","generatePublicContext","adapterAttr","replace","adapterOnScope","assign","error","message","_this","publicMethods","publicProps","_loop","attr","set","publicPropsImmediate","_loop2","newItems","arg3","applyUpdatesFunc","noAdjust","applyUpdatesIndex","cb","options","_this2","slice","applyUpdate","_index","isArray","immutableTop","_this3","position","some","newItem","rowTop","topHeight","topDone","bottomDone","itemTop","isEOF","constant","run","elt","jQuery","fn","jquery","registerFor","addCSSRules","directive","restrict","controller","child","console","$timeout","$interval","require","transclude","priority","terminal","link","controllers","linker","match","uiScroll","parseNumber","defaultValue","isFloat","isNaN","parseNumericAttr","datasource","itemName","datasourceName","allowVisibilityWatch","ridActual","pending","unbindEvents","scPreviousScrollTop","persistDatasourceIndex","isDatasourceValid","toString","onRenderHandlers","propName","handler","id","defineDatasourceIndex","propUserName","descriptor","getOwnPropertyDescriptor","scTimer","fetchNext","success","count","fetchPrevious","isInvalid","rid","$$destroyed","unbind","resizeAndScrollHandler","isElementVisible","insertWrapperContent","insertAfter","createElement","unregisterVisibilityWatcher","$watch","hideElement","promises","clone","transform","tdInitializer","uiScrollTdInitializer","linking","onLink","updatePaddings","animated","all","enqueueFetch","isPendingScroll","calculateAbsoluteScroll","inserted","loading","fetch","processUpdates","toBePrepended","toBeRemoved","removed","updateDOM","changes","$$phase","$digest","w","showElement","calculateProperties","doAdjustAfterFetch","shift","_resizeAndScrollHandler","sc","clearTimeout","setTimeout","newFirst","wheelHandler","event","yMax","clientHeight","preventDefault","$on","tryCount","timer","cancel","initialize"],"mappings":"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","file":"ui-scroll.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","/*!\n globals: angular, window\n List of used element methods available in JQuery but not in JQuery Lite\n element.before(elem)\n element.height()\n element.outerHeight(true)\n element.height(value) = only for Top/Bottom padding elements\n element.scrollTop()\n element.scrollTop(value)\n */\n\nexport default class JQLiteExtras {\n\n  registerFor(element) {\n    let convertToPx, css, getStyle, isWindow;\n    // angular implementation blows up if elem is the window\n    css = angular.element.prototype.css;\n\n    element.prototype.css = function (name, value) {\n      let self = this;\n      let elem = self[0];\n      if (!(!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style)) {\n        return css.call(self, name, value);\n      }\n    };\n\n    // as defined in angularjs v1.0.5\n    isWindow = (obj) => obj && obj.document && obj.location && obj.alert && obj.setInterval;\n\n    function scrollTo(self, direction, value) {\n      let elem = self[0];\n      let [method, prop, preserve] = {\n        top: [\n          'scrollTop',\n          'pageYOffset',\n          'scrollLeft'\n        ],\n        left: [\n          'scrollLeft',\n          'pageXOffset',\n          'scrollTop'\n        ]\n      }[direction];\n\n      const isValueDefined = typeof value !== 'undefined';\n      if (isWindow(elem)) {\n        if (isValueDefined) {\n          return elem.scrollTo(self[preserve].call(self), value);\n        }\n        return (prop in elem) ? elem[prop] : elem.document.documentElement[method];\n      } else {\n        if (isValueDefined) {\n          elem[method] = value;\n        }\n        return elem[method];\n      }\n    }\n\n    if (window.getComputedStyle) {\n      getStyle = (elem) => window.getComputedStyle(elem, null);\n      convertToPx = (elem, value) => parseFloat(value);\n    } else {\n      getStyle = (elem) => elem.currentStyle;\n      convertToPx = (elem, value) => {\n        let left, result, rs, rsLeft, style;\n        let core_pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\n        let rnumnonpx = new RegExp('^(' + core_pnum + ')(?!px)[a-z%]+$', 'i');\n\n        if (!rnumnonpx.test(value)) {\n          return parseFloat(value);\n        }\n\n        // ported from JQuery\n        style = elem.style;\n        left = style.left;\n        rs = elem.runtimeStyle;\n        rsLeft = rs && rs.left;\n        if (rs) {\n          rs.left = style.left;\n        }\n        // put in the new values to get a computed style out\n        style.left = value;\n        result = style.pixelLeft;\n        style.left = left;\n        if (rsLeft) {\n          rs.left = rsLeft;\n        }\n        return result;\n      };\n    }\n\n    function getMeasurements(elem, measure) {\n      let base, borderA, borderB, computedMarginA, computedMarginB, computedStyle, dirA, dirB, marginA, marginB, paddingA, paddingB;\n\n      if (isWindow(elem)) {\n        base = document.documentElement[{height: 'clientHeight', width: 'clientWidth'}[measure]];\n\n        return {\n          base: base,\n          padding: 0,\n          border: 0,\n          margin: 0\n        };\n      }\n\n      // Start with offset property\n      [\n        base,\n        dirA,\n        dirB\n      ] = {\n        width: [\n          elem.offsetWidth,\n          'Left',\n          'Right'\n        ],\n        height: [\n          elem.offsetHeight,\n          'Top',\n          'Bottom'\n        ]\n      }[measure];\n\n      computedStyle = getStyle(elem);\n      paddingA = convertToPx(elem, computedStyle['padding' + dirA]) || 0;\n      paddingB = convertToPx(elem, computedStyle['padding' + dirB]) || 0;\n      borderA = convertToPx(elem, computedStyle['border' + dirA + 'Width']) || 0;\n      borderB = convertToPx(elem, computedStyle['border' + dirB + 'Width']) || 0;\n      computedMarginA = computedStyle['margin' + dirA];\n      computedMarginB = computedStyle['margin' + dirB];\n\n      // I do not care for width for now, so this hack is irrelevant\n      // if ( !supportsPercentMargin )\n      // computedMarginA = hackPercentMargin( elem, computedStyle, computedMarginA )\n      // computedMarginB = hackPercentMargin( elem, computedStyle, computedMarginB )\n      marginA = convertToPx(elem, computedMarginA) || 0;\n      marginB = convertToPx(elem, computedMarginB) || 0;\n\n      return {\n        base: base,\n        padding: paddingA + paddingB,\n        border: borderA + borderB,\n        margin: marginA + marginB\n      };\n    }\n\n    function getWidthHeight(elem, direction, measure) {\n      let computedStyle, result;\n\n      let measurements = getMeasurements(elem, direction);\n\n      if (measurements.base > 0) {\n        return {\n          base: measurements.base - measurements.padding - measurements.border,\n          outer: measurements.base,\n          outerfull: measurements.base + measurements.margin\n        }[measure];\n      }\n\n      // Fall back to computed then uncomputed css if necessary\n      computedStyle = getStyle(elem);\n      result = computedStyle[direction];\n\n      if (result < 0 || result === null) {\n        result = elem.style[direction] || 0;\n      }\n\n      // Normalize \"\", auto, and prepare for extra\n      result = parseFloat(result) || 0;\n\n      return {\n        base: result - measurements.padding - measurements.border,\n        outer: result,\n        outerfull: result + measurements.padding + measurements.border + measurements.margin\n      }[measure];\n    }\n\n    // define missing methods\n    return angular.forEach({\n      before(newElem) {\n        var children, elem, i, j, parent, ref, self;\n        self = this;\n        elem = self[0];\n        parent = self.parent();\n        children = parent.contents();\n        if (children[0] === elem) {\n          return parent.prepend(newElem);\n        } else {\n          for (i = j = 1, ref = children.length - 1; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {\n            if (children[i] === elem) {\n              angular.element(children[i - 1]).after(newElem);\n              return;\n            }\n          }\n          throw new Error('invalid DOM structure ' + elem.outerHTML);\n        }\n      },\n      height (value){\n        var self;\n        self = this;\n        if (typeof value !== 'undefined') {\n          if (angular.isNumber(value)) {\n            value = value + 'px';\n          }\n          return css.call(self, 'height', value);\n        } else {\n          return getWidthHeight(this[0], 'height', 'base');\n        }\n      },\n      outerHeight(option) {\n        return getWidthHeight(this[0], 'height', option ? 'outerfull' : 'outer');\n      },\n      outerWidth(option) {\n        return getWidthHeight(this[0], 'width', option ? 'outerfull' : 'outer');\n      },\n\n      /*\n       The offset setter method is not implemented\n       */\n      offset(value) {\n        let docElem, win;\n        let self = this;\n        let box = {\n          top: 0,\n          left: 0\n        };\n        let elem = self[0];\n        let doc = elem && elem.ownerDocument;\n\n        if (arguments.length) {\n          if (value === undefined) {\n            return self;\n          }\n          // TODO: implement setter\n          throw new Error('offset setter method is not implemented');\n        }\n\n        if (!doc) {\n          return;\n        }\n\n        docElem = doc.documentElement;\n\n        // TODO: Make sure it's not a disconnected DOM node\n\n        if (elem.getBoundingClientRect != null) {\n          box = elem.getBoundingClientRect();\n        }\n\n        win = doc.defaultView || doc.parentWindow;\n\n        return {\n          top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),\n          left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)\n        };\n      },\n      scrollTop(value) {\n        return scrollTo(this, 'top', value);\n      },\n      scrollLeft(value) {\n        return scrollTo(this, 'left', value);\n      }\n    }, (value, key) => {\n      if (!element.prototype[key]) {\n        return element.prototype[key] = value;\n      }\n    });\n  }\n\n}\n","const hideClassToken = 'ng-ui-scroll-hide';\n\nexport default class ElementRoutines {\n\n  static addCSSRules() {\n    const selector = '.' + hideClassToken;\n    const rules = 'display: none';\n    const sheet = document.styleSheets[0];\n    let index;\n    try {\n      index = sheet.cssRules.length;\n    } catch (err) {\n      index = 0;\n    }\n    if('insertRule' in sheet) {\n      sheet.insertRule(selector + '{' + rules + '}', index);\n    }\n    else if('addRule' in sheet) {\n      sheet.addRule(selector, rules, index);\n    }\n  }\n\n  constructor($injector, $q) {\n    this.$animate = ($injector.has && $injector.has('$animate')) ? $injector.get('$animate') : null;\n    this.isAngularVersionLessThen1_3 = angular.version.major === 1 && angular.version.minor < 3;\n    this.$q = $q;\n  }\n\n  hideElement(wrapper) {\n    wrapper.element.addClass(hideClassToken);\n  }\n\n  showElement(wrapper) {\n    wrapper.element.removeClass(hideClassToken);\n  }\n\n  insertElement(newElement, previousElement) {\n    previousElement.after(newElement);\n    return [];\n  }\n\n  removeElement(wrapper) {\n    wrapper.element.remove();\n    wrapper.scope.$destroy();\n    return [];\n  }\n\n  insertElementAnimated(newElement, previousElement) {\n    if (!this.$animate) {\n      return this.insertElement(newElement, previousElement);\n    }\n\n    if (this.isAngularVersionLessThen1_3) {\n      const deferred = this.$q.defer();\n      // no need for parent - previous element is never null\n      this.$animate.enter(newElement, null, previousElement, () => deferred.resolve());\n\n      return [deferred.promise];\n    }\n\n    // no need for parent - previous element is never null\n    return [this.$animate.enter(newElement, null, previousElement)];\n  }\n\n  removeElementAnimated(wrapper) {\n    if (!this.$animate) {\n      return this.removeElement(wrapper);\n    }\n\n    if (this.isAngularVersionLessThen1_3) {\n      const deferred = this.$q.defer();\n      this.$animate.leave(wrapper.element, () => {\n        wrapper.scope.$destroy();\n        return deferred.resolve();\n      });\n\n      return [deferred.promise];\n    }\n\n    return [(this.$animate.leave(wrapper.element)).then(() => wrapper.scope.$destroy())];\n  }\n}","export default function ScrollBuffer(elementRoutines, bufferSize, startIndex, rowHeight) {\n  const buffer = Object.create(Array.prototype);\n\n  angular.extend(buffer, {\n    size: bufferSize,\n\n    reset(startIndex) {\n      buffer.remove(0, buffer.length);\n      buffer.eof = false;\n      buffer.bof = false;\n      buffer.first = startIndex;\n      buffer.next = startIndex;\n      buffer.minIndex = startIndex; // Calculated when data is effectively accessed\n      buffer.maxIndex = startIndex;\n      buffer.minIndexUser = null; // as set by the user (datasource)\n      buffer.maxIndexUser = null;\n    },\n    \n    // PHIL: set the new index to be displayed without resettng the sroll and the calculated min/max\n    // Note that this actually make sense with a fixed rowHeight when the scroll value can be calculated\n    // for a # of rows\n    resetStartIndex: function resetStartIndex(startIndex) {\n      buffer.remove(0, buffer.length);\n      buffer.eof = buffer.eof && startIndex==buffer.maxIndex;\n      buffer.bof = buffer.bof && startIndex==buffer.minIndex;\n      buffer.first = startIndex;\n      buffer.next = startIndex;\n    },\n\n    append(items) {\n      items.forEach((item) => {\n        ++buffer.next;\n        buffer.insert('append', item);\n      });\n      buffer.maxIndex = buffer.eof ? buffer.next - 1 : Math.max(buffer.next - 1, buffer.maxIndex);\n    },\n\n    prepend(items) {\n      items.reverse().forEach((item) => {\n        --buffer.first;\n        buffer.insert('prepend', item);\n      });\n      buffer.minIndex = buffer.bof ? buffer.minIndex = buffer.first : Math.min(buffer.first, buffer.minIndex);\n    },\n\n    /**\n     * inserts wrapped element in the buffer\n     * the first argument is either operation keyword (see below) or a number for operation 'insert'\n     * for insert the number is the index for the buffer element the new one have to be inserted after\n     * operations: 'append', 'prepend', 'insert', 'remove', 'update', 'none'\n     */\n    insert(operation, item, isTop) {\n      const wrapper = {\n        item: item\n      };\n\n      if (operation % 1 === 0) {// it is an insert\n        wrapper.op = 'insert';\n        buffer.splice(operation, 0, wrapper);\n        if(isTop) {\n          buffer.first--;\n        }\n        else {\n          buffer.next++;\n        }\n      } else {\n        wrapper.op = operation;\n        switch (operation) {\n          case 'append':\n            buffer.push(wrapper);\n            break;\n          case 'prepend':\n            buffer.unshift(wrapper);\n            break;\n        }\n      }\n    },\n\n    // removes elements from buffer\n    remove(arg1, arg2) {\n      if (angular.isNumber(arg1)) {\n        // removes items from arg1 (including) through arg2 (excluding)\n        for (let i = arg1; i < arg2; i++) {\n          elementRoutines.removeElement(buffer[i]);\n        }\n        return buffer.splice(arg1, arg2 - arg1);\n      }\n      // removes single item(wrapper) from the buffer\n      buffer.splice(buffer.indexOf(arg1), 1);\n      if(arg1._op === 'isTop' && buffer.first === this.getAbsMinIndex()) {\n        this.incrementMinIndex();\n      }\n      else {\n        this.decrementMaxIndex();\n      }\n      if(arg1._op === 'isTop') {\n        buffer.first++;\n      }\n      else {\n        buffer.next--;\n      }\n      if(!buffer.length) {\n        buffer.first = buffer.minIndex%1 ? buffer.minIndex : startIndex;\n        buffer.next = buffer.first;\n        buffer.eof = buffer.eof && buffer.first==buffer.maxIndex;\n      }\n\n      return elementRoutines.removeElementAnimated(arg1);\n    },\n\n    incrementMinIndex() {\n      if(buffer.minIndexUser !== null) {\n        if(buffer.minIndex > buffer.minIndexUser) {\n          buffer.minIndexUser++;\n          return;\n        }\n        if(buffer.minIndex === buffer.minIndexUser) {\n          buffer.minIndexUser++;\n        }\n      }\n      buffer.minIndex++;\n    },\n\n    decrementMaxIndex() {\n      if(buffer.maxIndexUser !== null && buffer.maxIndex <= buffer.maxIndexUser) {\n        buffer.maxIndexUser--;\n      }\n      buffer.maxIndex--;\n    },\n\n    getAbsMinIndex() {\n      if(buffer.minIndexUser !== null) {\n        return Math.min(buffer.minIndexUser, buffer.minIndex);\n      }\n      return buffer.minIndex;\n    },\n\n    getAbsMaxIndex() {\n      if(buffer.maxIndexUser !== null) {\n        return Math.max(buffer.maxIndexUser, buffer.maxIndex);\n      }\n      return buffer.maxIndex;\n    },\n\n    effectiveHeight(elements) {\n      if (!elements.length) {\n        return 0;\n      }\n      let top = Number.MAX_VALUE;\n      let bottom = Number.NEGATIVE_INFINITY;\n      elements.forEach((wrapper) => {\n        if (wrapper.element[0].offsetParent) {\n          // element style is not display:none\n          top = Math.min(top, wrapper.element.offset().top);\n          bottom = Math.max(bottom, wrapper.element.offset().top + (rowHeight || wrapper.element.outerHeight(true)));\n        }\n      });\n      return Math.max(0, bottom - top);\n    },\n\n    getItems() {\n      return buffer.filter(item => item.op === 'none');\n    },\n\n    getFirstItem() {\n      const list = buffer.getItems();\n      if (!list.length) {\n        return null;\n      }\n      return list[0].item;\n    },\n\n    getLastItem() {\n      const list = buffer.getItems();\n      if (!list.length) {\n        return null;\n      }\n      return list[list.length - 1].item;\n    }\n\n  });\n\n  buffer.reset(startIndex);\n\n  return buffer;\n}\n","// Can't just extend the Array, due to Babel does not support built-in classes extending\n// This solution was taken from https://stackoverflow.com/questions/46897414/es6-class-extends-array-workaround-for-es5-babel-transpile\nclass CacheProto {\n  add(item) {\n    for (let i = this.length - 1; i >= 0; i--) {\n      if (this[i].index === item.scope.$index) {\n        this[i].height = item.element.outerHeight();\n        return;\n      }\n    }\n    this.push({\n      index: item.scope.$index,\n      height: item.element.outerHeight()\n    });\n    this.sort((a, b) => ((a.index < b.index) ? -1 : ((a.index > b.index) ? 1 : 0)));\n  }\n\n  remove(argument, _isTop) {\n    const index = argument % 1 === 0 ? argument : argument.scope.$index;\n    const isTop = argument % 1 === 0 ? _isTop : argument._op === 'isTop';\n    for (let i = this.length - 1; i >= 0; i--) {\n      if (this[i].index === index) {\n        this.splice(i, 1);\n        break;\n      }\n    }\n    if(!isTop) {\n      for (let i = this.length - 1; i >= 0; i--) {\n        if (this[i].index > index) {\n          this[i].index--;\n        }\n      }\n    }\n  }\n\n  clear() {\n    this.length = 0;\n  }\n}\n\nfunction Cache() {\n  const instance = [];\n  instance.push.apply(instance, arguments);\n  Object.setPrototypeOf(instance, Cache.prototype);\n  return instance;\n}\nCache.prototype = Object.create(Array.prototype);\nObject.getOwnPropertyNames(CacheProto.prototype).forEach(methodName =>\n  Cache.prototype[methodName] = CacheProto.prototype[methodName]\n);\n\nfunction generateElement(template) {\n  if(template.nodeType !== Node.ELEMENT_NODE) {\n    throw new Error('ui-scroll directive requires an Element node for templating the view');\n  }\n  let element;\n  switch (template.tagName.toLowerCase()) {\n    case 'dl':\n      throw new Error(`ui-scroll directive does not support <${template.tagName}> as a repeating tag: ${template.outerHTML}`);\n    case 'tr':\n      let table = angular.element('<table><tr><td><div></div></td></tr></table>');\n      element = table.find('tr');\n      break;\n    case 'li':\n      element = angular.element('<li></li>');\n      break;\n    default:\n      element = angular.element('<div></div>');\n  }\n  return element;\n}\n\n//\n// Padding represents the dummy element added to both the top and the bottom of the scrolling container\n// It holds the element, as well as a cache for the items (rows) height. In case of a fixed rowHeight, the \n// cache is not used and thus is not created.\n//\nclass Padding {\n  constructor(template,useCache) {\n    this.element = generateElement(template);\n    if(useCache) {\n      this.cache = new Cache();\n    }\n  }\n\n  height() {\n    // When called with a parameter, this sets the height of the padding\n    return this.element.height.apply(this.element, arguments);\n  }\n}\n\nexport default Padding;","import Padding from './padding';\n\nexport default function Viewport(elementRoutines, buffer, element, viewportController, $rootScope, padding, rowHeight) {\n  let topPadding = null;\n  let bottomPadding = null;\n  const viewport = viewportController && viewportController.viewport ? viewportController.viewport : angular.element(window);\n  const container = viewportController && viewportController.container ? viewportController.container : undefined;\n  const scope = viewportController && viewportController.scope ? viewportController.scope : $rootScope;\n\n  viewport.css({\n    'overflow-anchor': 'none',\n    'overflow-y': 'auto',\n    'display': 'block'\n  });\n\n  function bufferPadding() {\n    return viewport.outerHeight() * padding; // some extra space to initiate preload\n  }\n\n  // \n  //   Viewport measurements\n  //\n  //     +----------------+  0\n  //     |      top       |\n  //     |    padding     |\n  //     +----------------+  topDataPos() [=topPadding.height]\n  //     |   not visible  |\n  //     |      items     |\n  //     +----------------+  topVisiblePos() [=viewport.scrollTop]\n  //     |                |\n  //     |     visible    |\n  //     |      items     |\n  //     |                |\n  //     +----------------+  bottomVisiblePos() [=viewport.scrollTop+viewport.height]\n  //     |   not visible  |\n  //     |      items     |\n  //     +----------------+  bottomDataPos() [=scrollHeight-bottomPadding.height]\n  //     |    bottom      |\n  //     |    padding     |\n  //     +----------------+  scrollHeight \n  //\n  // bufferPadding is some extra space we have top & bottom to allow infinite scrolling\n  //          bufferPadding = viewport.outerHeight() * padding\n  //\n  //  bottomVisiblePos() - topVisiblePos() == viewport.outerHeight()\n  \n\n  angular.extend(viewport, {\n    getScope() {\n      return scope;\n    },\n\n    createPaddingElements(template) {\n      topPadding = new Padding(template,!rowHeight);\n      bottomPadding = new Padding(template,!rowHeight);\n      element.before(topPadding.element);\n      element.after(bottomPadding.element);\n      topPadding.height(0);\n      bottomPadding.height(0);\n    },\n\n    applyContainerStyle() {\n      if (!container) {\n        return true;\n      }\n      if(container !== viewport) {\n        viewport.css('height', window.getComputedStyle(container[0]).height);\n      }\n      return viewport.height() > 0;\n    },\n\n    bottomDataPos() {\n      let scrollHeight = viewport[0].scrollHeight;\n      scrollHeight = scrollHeight != null ? scrollHeight : viewport[0].document.documentElement.scrollHeight;\n      return scrollHeight - bottomPadding.height();\n    },\n\n    topDataPos() {\n      return topPadding.height();\n    },\n\n    bottomVisiblePos() {\n      return viewport.scrollTop() + viewport.outerHeight();\n    },\n\n    topVisiblePos() {\n      return viewport.scrollTop();\n    },\n\n    insertElement(e, sibling) {\n      return elementRoutines.insertElement(e, sibling || topPadding.element);\n    },\n\n    insertElementAnimated(e, sibling) {\n      return elementRoutines.insertElementAnimated(e, sibling || topPadding.element);\n    },\n\n    shouldLoadBottom() {\n      return !buffer.eof && viewport.bottomDataPos() < viewport.bottomVisiblePos() + bufferPadding();\n    },\n\n    clipBottom() {\n      // clip the invisible items off the bottom\n      let overage = 0;\n      let emptySpaceHeight = viewport.bottomDataPos() - viewport.bottomVisiblePos() - bufferPadding();\n      if(rowHeight) {\n        overage = Math.min(buffer.length,Math.floor(emptySpaceHeight/rowHeight));\n      } else {\n        let itemHeight = 0;\n        let overageHeight = 0;\n\n        for (let i = buffer.length - 1; i >= 0; i--) {\n          itemHeight = buffer[i].element.outerHeight(true);\n          if (overageHeight + itemHeight > emptySpaceHeight) {\n            break;\n          }\n          bottomPadding.cache.add(buffer[i]);\n          overageHeight += itemHeight;\n          overage++;\n        }\n      }\n\n      if (overage > 0) {\n        buffer.eof = false;\n        buffer.remove(buffer.length - overage, buffer.length);\n        buffer.next -= overage;\n        viewport.adjustPaddings();\n      }\n    },\n\n    shouldLoadTop() {\n      return !buffer.bof && (viewport.topDataPos() > viewport.topVisiblePos() - bufferPadding());\n    },\n\n    clipTop() {\n      // clip the invisible items off the top\n      let overage = 0;\n      let overageHeight = 0;\n      let emptySpaceHeight = viewport.topVisiblePos() - viewport.topDataPos() - bufferPadding();\n      if(rowHeight) {\n        overage = Math.min(buffer.length,Math.floor(emptySpaceHeight/rowHeight));\n        overageHeight = overage * rowHeight;\n      } else {\n        let itemHeight = 0;\n\n        for (let i = 0; i < buffer.length; i++) {\n          itemHeight = buffer[i].element.outerHeight(true);\n          if (overageHeight + itemHeight > emptySpaceHeight) {\n            break;\n          }\n          topPadding.cache.add(buffer[i]);\n          overageHeight += itemHeight;\n          overage++;\n        }\n      }\n\n      if (overage > 0) {\n        // we need to adjust top padding element before items are removed from top\n        // to avoid strange behaviour of scroll bar during remove top items when we are at the very bottom\n        topPadding.height(topPadding.height() + overageHeight);\n        buffer.bof = false;\n        buffer.remove(0, overage);\n        buffer.first += overage;\n      }\n    },\n\n    // PHIL: remove all the entries in the buffer without changing the scrollbar, nor the scroll position\n    // and update the padding accordingly\n    // It is designed to work with non fixed rowHeight, although it will need more tests in this area...\n    scrollTo(first) {\n      if(rowHeight) {\n        const min = buffer.getAbsMinIndex(); \n        const max = buffer.getAbsMaxIndex();\n        first = Math.min(Math.max(first, min),max);\n        // Adjust the paddings before removing the elements to avoid touching the scroll top position\n        topPadding.height((first-min)*rowHeight);\n        bottomPadding.height(((max+1)-first)*rowHeight);\n        buffer.resetStartIndex(first);\n      } else {\n        buffer.resetStartIndex(first);\n        viewport.adjustPaddings();\n      } \n    },\n   \n    adjustPaddings() {\n      if(rowHeight) {\n        const min = buffer.getAbsMinIndex(); \n        const max = buffer.getAbsMaxIndex();\n        topPadding.height((buffer.first-min)*rowHeight);\n        // PHIL: next points to the next possible item, while max is the index of the last one.\n        // In order to make them compatible, we should add one to max\n        // Also, it looks like buffer is not changing maxIndex when an element is inserted/appended\n        // Not sure if this can have a consequence or not....\n        bottomPadding.height(((max+1)-buffer.next)*rowHeight);\n        return;\n      }\n\n      if (!buffer.length) {\n        return;\n      }\n\n      // precise heights calculation based on items that are in buffer or that were in buffer once\n      const visibleItemsHeight = buffer.reduce((summ, item) => summ + item.element.outerHeight(true), 0);\n      let topPaddingHeight = 0, topCount = 0;\n      topPadding.cache.forEach(item => {\n        if(item.index < buffer.first) {\n          topPaddingHeight += item.height;\n          topCount++;\n        }\n      });\n \n      let bottomPaddingHeight = 0, bottomCount = 0;\n      bottomPadding.cache.forEach(item => {\n        if(item.index >= buffer.next) {\n          bottomPaddingHeight += item.height;\n          bottomCount++;\n        }\n      });\n \n      const totalHeight = visibleItemsHeight + topPaddingHeight + bottomPaddingHeight;\n      const averageItemHeight = totalHeight / (topCount + bottomCount + buffer.length);   \n\n      // average heights calculation, items that have never been reached\n      let adjustTopPadding = buffer.minIndexUser !== null && buffer.minIndex > buffer.minIndexUser;\n      let adjustBottomPadding = buffer.maxIndexUser !== null && buffer.maxIndex < buffer.maxIndexUser;\n      let topPaddingHeightAdd = adjustTopPadding ? (buffer.minIndex - buffer.minIndexUser) * averageItemHeight : 0;\n      let bottomPaddingHeightAdd = adjustBottomPadding ? (buffer.maxIndexUser - buffer.maxIndex) * averageItemHeight : 0;\n\n      // paddings combine adjustment\n      topPadding.height(topPaddingHeight + topPaddingHeightAdd);\n      bottomPadding.height(bottomPaddingHeight + bottomPaddingHeightAdd);\n    },\n\n    onAfterMinIndexSet(topPaddingHeightOld) {\n      // additional scrollTop adjustment in case of datasource.minIndex external set\n      if (buffer.minIndexUser !== null && buffer.minIndex > buffer.minIndexUser) {\n        let diff = topPadding.height() - topPaddingHeightOld;\n        viewport.scrollTop(viewport.scrollTop() + diff);\n        while((diff -= viewport.scrollTop()) > 0) {\n          bottomPadding.height(bottomPadding.height() + diff);\n          viewport.scrollTop(viewport.scrollTop() + diff);\n        }\n      }\n    },\n\n    onAfterPrepend(updates) {\n      if (!updates.prepended.length)\n        return;\n      const height = buffer.effectiveHeight(updates.prepended);\n      const paddingHeight = topPadding.height() - height;\n      if (paddingHeight >= 0) {\n        topPadding.height(paddingHeight);\n      }\n      else {\n        topPadding.height(0);\n        viewport.scrollTop(viewport.scrollTop() - paddingHeight);\n      }\n    },\n\n    resetTopPadding() {\n      topPadding.height(0);\n      if(topPadding.cache) {\n        topPadding.cache.clear();\n      }\n    },\n\n    resetBottomPadding() {\n      bottomPadding.height(0);\n      if(bottomPadding.cache) {\n        bottomPadding.cache.clear();\n      }\n    },\n\n    removeCacheItem(item, isTop) {\n      if(topPadding.cache) {\n        topPadding.cache.remove(item, isTop);\n      }\n      if(bottomPadding.cache) {\n        bottomPadding.cache.remove(item, isTop);\n      }\n    },\n\n    removeItem(item) {\n      this.removeCacheItem(item);\n      return buffer.remove(item);\n    }\n  });\n\n  return viewport;\n}\n","class Adapter {\n\n  constructor($scope, $parse, $attr, viewport, buffer, doAdjust, reload) {\n    this.$parse = $parse;\n    this.$attr = $attr;\n    this.viewport = viewport;\n    this.buffer = buffer;\n\n    this.doAdjust = doAdjust;\n    this.reload = reload;\n\n    this.isLoading = false;\n    this.disabled = false;\n\n    const viewportScope = viewport.getScope();\n    this.startScope = viewportScope.$parent ? viewportScope : $scope;\n\n    this.publicContext = {};\n    this.assignAdapter($attr.adapter);\n    this.generatePublicContext();\n  }\n\n  assignAdapter(adapterAttr) {\n    if (!adapterAttr || !(adapterAttr = adapterAttr.replace(/^\\s+|\\s+$/gm, ''))) {\n      return;\n    }\n    let adapterOnScope;\n\n    try {\n      this.$parse(adapterAttr).assign(this.startScope, {});\n      adapterOnScope = this.$parse(adapterAttr)(this.startScope);\n    }\n    catch (error) {\n      error.message = `Angular ui-scroll Adapter assignment exception.\\n` +\n        `Can't parse \"${adapterAttr}\" expression.\\n` +\n        error.message;\n      throw error;\n    }\n\n    angular.extend(adapterOnScope, this.publicContext);\n    this.publicContext = adapterOnScope;\n  }\n\n  generatePublicContext() {\n    // these methods will be accessible out of ui-scroll via user defined adapter\n    const publicMethods = ['reload', 'applyUpdates', 'append', 'prepend', 'isBOF', 'isEOF', 'isEmpty'];\n    for (let i = publicMethods.length - 1; i >= 0; i--) {\n      this.publicContext[publicMethods[i]] = this[publicMethods[i]].bind(this);\n    }\n\n    // these read-only props will be accessible out of ui-scroll via user defined adapter\n    const publicProps = ['isLoading', 'topVisible', 'topVisibleElement', 'topVisibleScope', 'bottomVisible', 'bottomVisibleElement', 'bottomVisibleScope'];\n    for (let i = publicProps.length - 1; i >= 0; i--) {\n      let property, attr = this.$attr[publicProps[i]];\n      Object.defineProperty(this, publicProps[i], {\n        get: () => property,\n        set: (value) => {\n          property = value;\n          this.publicContext[publicProps[i]] = value;\n          if (attr) {\n            this.$parse(attr).assign(this.startScope, value);\n          }\n        }\n      });\n    }\n\n    // read-only immediately calculated public properties\n    const publicPropsImmediate = ['bufferFirst', 'bufferLast', 'bufferLength'];\n    for (let i = publicPropsImmediate.length - 1; i >= 0; i--) {\n      Object.defineProperty(this.publicContext, publicPropsImmediate[i], {\n        get: () => this[publicPropsImmediate[i]]\n      });\n    }\n\n    // non-read-only public property\n    Object.defineProperty(this.publicContext, 'disabled', {\n      get: () => this.disabled,\n      set: (value) => (!(this.disabled = value)) ? this.doAdjust() : null\n    });\n  }\n\n  loading(value) {\n    this.isLoading = value;\n  }\n\n  isBOF() {\n    return this.buffer.bof;\n  }\n\n  isEOF() {\n    return this.buffer.eof;\n  }\n\n  isEmpty() {\n    return !this.buffer.length;\n  }\n\n  get bufferLength() {\n    return this.buffer.getItems().length;\n  }\n\n  get bufferFirst() {\n    return this.buffer.getFirstItem();\n  }\n\n  get bufferLast() {\n    return this.buffer.getLastItem();\n  }\n\n  append(newItems) {\n    this.buffer.append(newItems);\n    this.doAdjust();\n    this.viewport.clipTop();\n    this.viewport.clipBottom();\n  }\n\n  prepend(newItems) {\n    this.buffer.prepend(newItems);\n    this.doAdjust();\n    this.viewport.clipTop();\n    this.viewport.clipBottom();\n  }\n\n  applyUpdates(arg1, arg2, arg3) {\n    if (typeof arg1 === 'function') {\n      this.applyUpdatesFunc(arg1, arg2);\n      if(arg2 && arg2.noAdjust) return;\n    } else {\n      this.applyUpdatesIndex(arg1, arg2, arg3);\n      if(arg3 && arg3.noAdjust) return;\n    }\n    this.doAdjust();\n  }\n\n  applyUpdatesFunc(cb, options) {\n    this.buffer.slice(0).forEach((wrapper) => {\n      // we need to do it on the buffer clone, because buffer content\n      // may change as we iterate through\n      this.applyUpdate(wrapper, cb(wrapper.item, wrapper.scope, wrapper.element), options);\n    });\n  }\n\n  applyUpdatesIndex(index, newItems, options = {}) {\n    if (index % 1 !== 0) {\n      throw new Error('applyUpdates - ' + index + ' is not a valid index (should be an integer)');\n    }\n    const _index = index - this.buffer.first;\n\n    // apply updates only within buffer\n    if (_index >= 0 && _index < this.buffer.length) {\n      this.applyUpdate(this.buffer[_index], newItems, options);\n    }\n    // out-of-buffer case: deletion may affect Paddings\n    else if(index >= this.buffer.getAbsMinIndex() && index <= this.buffer.getAbsMaxIndex()) {\n      if(angular.isArray(newItems) && !newItems.length) {\n        this.viewport.removeCacheItem(index, !options.immutableTop && index === this.buffer.minIndex);\n        if (!options.immutableTop && index === this.buffer.getAbsMinIndex()) {\n          this.buffer.incrementMinIndex();\n        }\n        else {\n          this.buffer.decrementMaxIndex();\n        }\n      }\n    }\n  }\n\n  applyUpdate(wrapper, newItems, options = {}) {\n    if (!angular.isArray(newItems)) {\n      return;\n    }\n    let position = this.buffer.indexOf(wrapper);\n    if (!newItems.reverse().some(newItem => newItem === wrapper.item)) {\n      wrapper.op = 'remove';\n      if (!options.immutableTop && position === 0 && !newItems.length) {\n        wrapper._op = 'isTop'; // to catch \"first\" edge case on remove\n      }\n    }\n    newItems.forEach((newItem) => {\n      if (newItem === wrapper.item) {\n        position--;\n      } else {\n        // 3 parameter (isTop) is to catch \"first\" edge case on insert\n        this.buffer.insert(position + 1, newItem, !options.immutableTop && position === -1);\n      }\n    });\n  }\n\n  calculateProperties() {\n    let rowTop = null, topHeight = 0;\n    let topDone = false, bottomDone = false;\n    const length = this.buffer.length;\n\n    for (let i = 0; i < length; i++) {\n      const item = this.buffer[i];\n      const itemTop = item.element.offset().top;\n\n      if (rowTop !== itemTop) { // a new row condition\n        const itemHeight = item.element.outerHeight(true);\n        const top = this.viewport.topDataPos() + topHeight + itemHeight;\n\n        if (!topDone && top > this.viewport.topVisiblePos()) {\n          topDone = true;\n          this['topVisible'] = item.item;\n          this['topVisibleElement'] = item.element;\n          this['topVisibleScope'] = item.scope;\n        }\n        if (!bottomDone && (top >= this.viewport.bottomVisiblePos() || (i === length - 1 && this.isEOF()))) {\n          bottomDone = true;\n          this['bottomVisible'] = item.item;\n          this['bottomVisibleElement'] = item.element;\n          this['bottomVisibleScope'] = item.scope;\n        }\n        topHeight += itemHeight;\n      }\n      rowTop = itemTop;\n\n      if (topDone && bottomDone) {\n        break;\n      }\n    }\n  }\n\n}\n\nexport default Adapter;\n","import JQLiteExtras from './modules/jqLiteExtras';\nimport ElementRoutines from './modules/elementRoutines.js';\nimport ScrollBuffer from './modules/buffer.js';\nimport Viewport from './modules/viewport.js';\nimport Adapter from './modules/adapter.js';\n\nangular.module('ui.scroll', [])\n\n  .constant('JQLiteExtras', JQLiteExtras)\n  .run(['JQLiteExtras', (JQLiteExtras) => {\n    const elt = angular.element;\n    !(window.jQuery && elt.fn && elt.fn.jquery) ? (new JQLiteExtras()).registerFor(elt) : null;\n    ElementRoutines.addCSSRules();\n  }])\n\n  .directive('uiScrollViewport', function () {\n    return {\n      restrict: 'A',\n      controller: [\n        '$scope',\n        '$element',\n        function (scope, element) {\n          this.container = element;\n          this.viewport = element;\n          this.scope = scope;\n\n          angular.forEach(element.children(), child => {\n            if (child.tagName.toLowerCase() === 'tbody') {\n              this.viewport = angular.element(child);\n            }\n          });\n\n          return this;\n        }\n      ]\n    };\n  })\n\n  .directive('uiScroll', [\n    '$log',\n    '$injector',\n    '$rootScope',\n    '$timeout',\n    '$interval',\n    '$q',\n    '$parse',\n    function (console, $injector, $rootScope, $timeout, $interval, $q, $parse) {\n\n      return {\n        require: ['?^uiScrollViewport'],\n        restrict: 'A',\n        transclude: 'element',\n        priority: 1000,\n        terminal: true,\n        link: link\n      };\n\n      function link($scope, element, $attr, controllers, linker) {\n        const match = $attr.uiScroll.match(/^\\s*(\\w+)\\s+in\\s+([(\\w|\\$)\\.]+)\\s*$/);\n        if (!match) {\n          throw new Error('Expected uiScroll in form of \\'_item_ in _datasource_\\' but got \\'' + $attr.uiScroll + '\\'');\n        }\n\n        function parseNumber(value, defaultValue, isFloat) {\n          if (!isFloat) {\n            value = value === null ? defaultValue : Math.floor(value);\n          }\n          return isNaN(value) ? defaultValue : value;\n        }\n\n        function parseNumericAttr(value, defaultValue, isFloat) {\n          const result = $parse(value)($scope);\n          return parseNumber(result, defaultValue, isFloat);\n        }\n\n        const BUFFER_MIN = 3; // Minimum size of the data source request\n        const BUFFER_DEFAULT = 10; // Default datasource request size\n        const PADDING_MIN = 0.3; // Mininum # of rows in the padding area\n        const PADDING_DEFAULT = 0.5; // Default # of rows in the padding area\n        const START_INDEX_DEFAULT = 1; // Default start index when requestng the first data block\n        const MAX_VIEWPORT_DELAY = 500; // Max time wait (ms) to get the viewport with an height>0\n        const VIEWPORT_POLLING_INTERVAL = 50; // Interval used to check the initial viewport height\n\n        let datasource = null;\n        const itemName = match[1]; // Name of the index variable to publish\n        const datasourceName = match[2]; // Name of the datasource to request the rows from\n        const viewportController = controllers[0]; // ViewportController, as specified in the require option (http://websystique.com/angularjs/angularjs-custom-directives-controllers-require-option-guide/)\n        const bufferSize = Math.max(BUFFER_MIN, parseNumericAttr($attr.bufferSize, BUFFER_DEFAULT)); \n        const padding = Math.max(PADDING_MIN, parseNumericAttr($attr.padding, PADDING_DEFAULT, true));\n        let startIndex = parseNumericAttr($attr.startIndex, START_INDEX_DEFAULT);\n\n        // PHIL: Provide a fixed row height\n        // \n        const rowHeight = parseNumericAttr($attr.rowHeight, null, false);\n\n        // PHIL: Read the visibility watch option, true by default\n        const allowVisibilityWatch = $attr.allowVisibilityWatch!=='false';\n\n        // Revision IDs\n        // \n        let ridActual = 0; // current data revision id\n        let pending = [];\n\n        const elementRoutines = new ElementRoutines($injector, $q);\n        const buffer = new ScrollBuffer(elementRoutines, bufferSize, startIndex, rowHeight);\n        const viewport = new Viewport(elementRoutines, buffer, element, viewportController, $rootScope, padding, rowHeight);\n        const adapter = new Adapter($scope, $parse, $attr, viewport, buffer, doAdjust, reload);\n\n        if (viewportController) {\n          viewportController.adapter = adapter;\n        }\n\n        // Currently, we only debounce the scroll events when a fixed rowHeight is provided\n        // as the unit tests will have to be adapted to support this feature\n        let scPreviousScrollTop=-1;\n\n        const isDatasourceValid = () =>\n          Object.prototype.toString.call(datasource) === '[object Object]' && typeof datasource.get === 'function';\n\n        datasource = $parse(datasourceName)($scope); // try to get datasource on scope\n        if (!isDatasourceValid()) {\n          datasource = $injector.get(datasourceName); // try to inject datasource as service\n          if (!isDatasourceValid()) {\n            throw new Error(datasourceName + ' is not a valid datasource');\n          }\n        }\n\n        let onRenderHandlers = [];\n        function onRenderHandlersRunner() {\n          onRenderHandlers.forEach(handler => handler.run());\n          onRenderHandlers = [];\n        }\n        function persistDatasourceIndex(datasource, propName) {\n          let getter;\n          // need to postpone min/maxIndexUser processing if the view is empty\n          if(angular.isNumber(datasource[propName])) {\n            getter = datasource[propName];\n            if(angular.isNumber(getter)) {\n              onRenderHandlers = onRenderHandlers.filter(handler => handler.id !== propName);\n              onRenderHandlers.push({\n                id: propName,\n                run: () => datasource[propName] = getter\n              });\n            }\n          }\n        }\n\n        function defineDatasourceIndex(datasource, propName, propUserName) {\n          const descriptor = Object.getOwnPropertyDescriptor(datasource, propName);\n          if (descriptor && (descriptor.set || descriptor.get)) {\n            return;\n          }\n          let getter;\n          persistDatasourceIndex(datasource, propName);\n          Object.defineProperty(datasource, propName, {\n            set: (value) => {\n              getter = value;\n              if(pending.length && !buffer.length) {\n                persistDatasourceIndex(datasource, propName);\n                return;\n              }\n              buffer[propUserName] = value;\n              const topPaddingHeightOld = viewport.topDataPos();\n              viewport.adjustPaddings();\n              if (propName === 'minIndex') {\n                viewport.onAfterMinIndexSet(topPaddingHeightOld);\n              }\n            },\n            get: () => getter\n          });\n        }\n\n        defineDatasourceIndex(datasource, 'minIndex', 'minIndexUser');\n        defineDatasourceIndex(datasource, 'maxIndex', 'maxIndexUser');\n\n        const fetchNext = (datasource.get.length !== 2) ?\n          (success) => datasource.get(buffer.next, bufferSize, success) :\n          (success) => {\n            datasource.get({\n              index: buffer.next,\n              append: buffer.length ? buffer[buffer.length - 1].item : void 0,\n              count: bufferSize\n            }, success);\n          };\n\n        const fetchPrevious = (datasource.get.length !== 2) ?\n          (success) => datasource.get(buffer.first - bufferSize, bufferSize, success) :\n          (success) => {\n            datasource.get({\n              index: buffer.first - bufferSize,\n              prepend: buffer.length ? buffer[0].item : void 0,\n              count: bufferSize\n            }, success);\n          };\n\n        const initialize = () => {\n          let tryCount = 0;\n          if(!viewport.applyContainerStyle()) {\n            const timer = $interval(() => {\n              tryCount++;\n              if(viewport.applyContainerStyle()) {\n                $interval.cancel(timer);\n                doAdjust();\n              }\n              if(tryCount * VIEWPORT_POLLING_INTERVAL >= MAX_VIEWPORT_DELAY) {\n                $interval.cancel(timer);\n                throw Error(`ui-scroll directive requires a viewport with non-zero height in ${MAX_VIEWPORT_DELAY}ms`);\n              }\n            }, VIEWPORT_POLLING_INTERVAL);\n          }\n          else {\n            doAdjust();\n          }\n        };\n\n        /**\n         * Build padding elements\n         *\n         * Calling linker is the only way I found to get access to the tag name of the template\n         * to prevent the directive scope from pollution a new scope is created and destroyed\n         * right after the builder creation is completed\n         */\n        linker((clone, scope) => {\n          viewport.createPaddingElements(clone[0]);\n          // we do not include the clone in the DOM. It means that the nested directives will not\n          // be able to reach the parent directives, but in this case it is intentional because we\n          // created the clone to access the template tag name\n          scope.$destroy();\n          clone.remove();\n        });\n\n        $scope.$on('$destroy', () => {\n          unbindEvents();\n          viewport.unbind('mousewheel', wheelHandler);\n        });\n\n        viewport.bind('mousewheel', wheelHandler);\n\n        initialize();\n\n        /* Private function definitions */\n\n        function isInvalid(rid) {\n          return (rid && rid !== ridActual) || $scope.$$destroyed;\n        }\n\n        function bindEvents() {\n          viewport.bind('resize', resizeAndScrollHandler);\n          viewport.bind('scroll', resizeAndScrollHandler);\n          // If a scroll event happened while the handler was not bounded, emit the scroll\n          if(isPendingScroll()) {\n            // Do it immediately\n            _resizeAndScrollHandler();\n          }\n        }\n\n        function unbindEvents() {\n          viewport.unbind('resize', resizeAndScrollHandler);\n          viewport.unbind('scroll', resizeAndScrollHandler);\n        }\n\n        function reload() {\n          unbindEvents();\n          viewport.resetTopPadding();\n          viewport.resetBottomPadding();\n          if (arguments.length) {\n            startIndex = parseNumber(arguments[0], START_INDEX_DEFAULT, false);\n          }\n          buffer.reset(startIndex);\n          scPreviousScrollTop = -1; // Avoid isScrollPending() to be true\n          persistDatasourceIndex(datasource, 'minIndex');\n          persistDatasourceIndex(datasource, 'maxIndex');\n          doAdjust();\n        }\n\n        function scrollTo(first) {\n          unbindEvents();\n          viewport.scrollTo(first);\n          doAdjust();\n        }\n\n        function isElementVisible(wrapper) {\n          return (rowHeight || wrapper.element.height()) && wrapper.element[0].offsetParent;\n        }\n\n        function visibilityWatcher(wrapper) {\n          if (isElementVisible(wrapper)) {\n            buffer.forEach((item) => {\n              if (typeof item.unregisterVisibilityWatcher === 'function') {\n                item.unregisterVisibilityWatcher();\n                delete item.unregisterVisibilityWatcher;\n              }\n            });\n            if (!pending.length) {\n              $timeout(() => doAdjust());\n            }\n          }\n        }\n\n        function insertWrapperContent(wrapper, insertAfter) {\n          createElement(wrapper, insertAfter, viewport.insertElement);\n          if (allowVisibilityWatch && !isElementVisible(wrapper)) {\n            wrapper.unregisterVisibilityWatcher = wrapper.scope.$watch(() => visibilityWatcher(wrapper));\n          }\n          if (allowVisibilityWatch) {\n            elementRoutines.hideElement(wrapper); // hide inserted elements before data binding\n          }\n        }\n\n        function createElement(wrapper, insertAfter, insertElement) {\n          let promises = null;\n          const sibling = (insertAfter > 0) ? buffer[insertAfter - 1].element : undefined;\n          linker((clone, scope) => {\n            promises = insertElement(clone, sibling);\n            wrapper.element = clone;\n            wrapper.scope = scope;\n            scope[itemName] = wrapper.item;\n          });\n          // ui-scroll-grid apply\n          if (adapter.transform) {\n            const tdInitializer = wrapper.scope.uiScrollTdInitializer;\n            if (tdInitializer && tdInitializer.linking) {\n              adapter.transform(wrapper.scope, wrapper.element);\n            } else {\n              wrapper.scope.uiScrollTdInitializer = {\n                onLink: () => adapter.transform(wrapper.scope, wrapper.element),\n                scope: wrapper.scope\n              };\n            }\n          }\n          return promises;\n        }\n\n        function updateDOM() {\n          let promises = [];\n          const toBePrepended = [];\n          const toBeRemoved = [];\n          const inserted = [];\n\n          buffer.forEach((wrapper, i) => {\n            switch (wrapper.op) {\n              case 'prepend':\n                toBePrepended.unshift(wrapper);\n                break;\n              case 'append':\n                insertWrapperContent(wrapper, i);\n                wrapper.op = 'none';\n                inserted.push(wrapper);\n                break;\n              case 'insert':\n                promises = promises.concat(createElement(wrapper, i, viewport.insertElementAnimated));\n                wrapper.op = 'none';\n                inserted.push(wrapper);\n                break;\n              case 'remove':\n                toBeRemoved.push(wrapper);\n            }\n          });\n\n          toBeRemoved.forEach((wrapper) => promises = promises.concat(viewport.removeItem(wrapper)));\n\n          if (toBePrepended.length)\n            toBePrepended.forEach((wrapper) => {\n              insertWrapperContent(wrapper);\n              wrapper.op = 'none';\n            });\n\n          buffer.forEach((item, i) => item.scope.$index = buffer.first + i);\n\n          return {\n            prepended: toBePrepended,\n            removed: toBeRemoved,\n            inserted: inserted,\n            animated: promises\n          };\n\n        }\n\n        // Adjust the viewport paddings\n        // \n        function updatePaddings(rid, updates) {\n          // schedule another doAdjust after animation completion\n          if (updates.animated.length) {\n            $q.all(updates.animated).then(() => {\n              viewport.adjustPaddings();\n              doAdjust(rid);\n            });\n          } else {\n            viewport.adjustPaddings();\n          }\n        }\n\n        function enqueueFetch(rid, updates) {\n          // If there is a scroll pending, we don't enqueue the fetch as the scroll might be an absolute scroll\n          // So we don't need to load top or bottom\n          // This happens when there is a scroll frenzi, and the $digest is slow enough, so it stacks the calls without\n          // giving a chance to the scroll event to be emitted and processed.\n          // We also do that if it leads to an absolute scroll\n          if(isPendingScroll() && calculateAbsoluteScroll()!==undefined) {\n            // Looks like the event is swallowed on some browsers (FF) on some scroll configuration\n            resizeAndScrollHandler();\n            return;\n          }\n\n          if (viewport.shouldLoadBottom()) {\n            if (!updates || buffer.effectiveHeight(updates.inserted) > 0) {\n              // this means that at least one item appended in the last batch has height > 0\n              if (pending.push(true) === 1) {\n                adapter.loading(true);\n                fetch(rid);\n              }\n            }\n          } else if (viewport.shouldLoadTop()) {\n            if ((!updates || buffer.effectiveHeight(updates.prepended) > 0) || pending[0]) {\n              // this means that at least one item appended in the last batch has height > 0\n              // pending[0] = true means that previous fetch was appending. We need to force at least one prepend\n              // BTW there will always be at least 1 element in the pending array because bottom is fetched first\n              if (pending.push(false) === 1) {\n                adapter.loading(true);\n                fetch(rid);\n              }\n            }\n          }\n        }\n\n        function processUpdates() {\n          const updates = updateDOM();\n\n          // We need the item bindings to be processed before we can do adjustments\n          // If there  are no changes and the row-height is static, then ignore it!\n          const changes = updates.animated.length+updates.inserted.length+updates.prepended.length+updates.removed.length;\n          if(changes || !rowHeight) {\n            !$scope.$$phase && !$rootScope.$$phase && $scope.$digest();\n          }\n\n          if (allowVisibilityWatch) {\n            updates.inserted.forEach(w => elementRoutines.showElement(w));\n            updates.prepended.forEach(w => elementRoutines.showElement(w));\n          }\n\n          return updates;\n        }\n\n        function doAdjust(rid) {\n          if (!rid) { // dismiss pending requests\n            pending = [];\n            rid = ++ridActual;\n          }\n\n          const updates = processUpdates();\n\n          if (isInvalid(rid)) {\n            return;\n          }\n\n          updatePaddings(rid, updates);\n          enqueueFetch(rid);\n\n          if (!pending.length) {\n            adapter.calculateProperties();\n          }\n        }\n\n        function doAdjustAfterFetch(rid) {\n          const updates = processUpdates();\n\n          viewport.onAfterPrepend(updates);\n\n          if (isInvalid(rid)) {\n            return;\n          }\n\n          updatePaddings(rid, updates);\n          onRenderHandlersRunner();\n          enqueueFetch(rid, updates);\n          pending.shift();\n\n          if (pending.length)\n            fetch(rid);\n          else {\n            adapter.loading(false);\n            bindEvents();\n            adapter.calculateProperties();\n          }\n        }\n\n        function fetch(rid) {\n          if (pending[0]) {// scrolling down\n            if (buffer.length && !viewport.shouldLoadBottom()) {\n              doAdjustAfterFetch(rid);\n            } else {\n              fetchNext((result) => {\n                if (isInvalid(rid)) {\n                  return;\n                }\n\n                if (result.length < bufferSize) {\n                  buffer.eof = true;\n                }\n\n                if (result.length > 0) {\n                  viewport.clipTop();\n                  buffer.append(result);\n                }\n\n                doAdjustAfterFetch(rid);\n              });\n            }\n          } else {  // scrolling up\n            if (buffer.length && !viewport.shouldLoadTop()) {\n              doAdjustAfterFetch(rid);\n            } else {\n              fetchPrevious((result) => {\n                if (isInvalid(rid)) {\n                  return;\n                }\n\n                if (result.length < bufferSize) {\n                  buffer.bof = true;\n                  // log 'bof is reached'\n                }\n\n                if (result.length > 0) {\n                  if (buffer.length) {\n                    viewport.clipBottom();\n                  }\n                  buffer.prepend(result);\n                }\n\n                doAdjustAfterFetch(rid);\n              });\n            }\n          }\n        }\n\n        function isPendingScroll() {\n          if(rowHeight) {\n            // Maybe the scroll changed but the event has *not* yet being dispatched\n            // because of the $digest running and taking to long\n            var sc = viewport.scrollTop();\n            if(sc!=scPreviousScrollTop && scPreviousScrollTop>=0) {\n              return true;\n            }\n          }\n          return false;\n        }\n\n        // Deboucing the scroll events avois intermediate $digest when scrolling fast\n        let scTimer;\n        function resizeAndScrollHandler() {\n          if (rowHeight) {\n            if (scTimer) clearTimeout(scTimer);\n            scTimer = setTimeout(_resizeAndScrollHandler, 50);\n          } else {\n            _resizeAndScrollHandler();\n          }\n        }\n\n        function _resizeAndScrollHandler() {\n          if (!$rootScope.$$phase && !adapter.isLoading && !adapter.disabled) {\n            // Absolute positioning currently only works when a fixed rowHeight is provided\n            // We might isolate the averegaRowHeight calculation in the viewport to provide an estimate\n            // and provide a reasonable behavior with variable height as well\n            if(rowHeight) {\n              const newFirst = calculateAbsoluteScroll();\n              if(newFirst!==undefined) {\n                scrollTo(newFirst);\n                return;\n              }\n            }\n\n            enqueueFetch(ridActual);\n\n            if (pending.length) {\n              unbindEvents();\n            } else {\n              adapter.calculateProperties();\n              if(!rowHeight) {\n                // The digest is forced to calculate the height, which is not necessary when the height is knowm\n                !$scope.$$phase && $scope.$digest();\n              }\n            }\n          }\n        }\n\n        function calculateAbsoluteScroll() {\n            if(rowHeight) {\n              scPreviousScrollTop = viewport.scrollTop();\n              let newFirst = Math.floor(viewport.scrollTop() / rowHeight) + buffer.getAbsMinIndex();\n              newFirst = Math.max(buffer.getAbsMinIndex(), Math.min(buffer.getAbsMaxIndex(),newFirst)); // Bound the scroll\n              if (newFirst<buffer.first-bufferSize) {\n                return newFirst;\n              }         \n              if (newFirst>buffer.next+bufferSize) {\n                return newFirst;\n              }         \n            }\n            return undefined;\n        }\n\n        function wheelHandler(event) {\n          if (!adapter.disabled) {\n            const scrollTop = viewport[0].scrollTop;\n            const yMax = viewport[0].scrollHeight - viewport[0].clientHeight;\n\n            if ((scrollTop === 0 && !buffer.bof) || (scrollTop === yMax && !buffer.eof)) {\n              event.preventDefault();\n            }\n          }\n        }\n      }\n\n    }\n  ]);\n"],"sourceRoot":""}