{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/modules/jqLiteExtras.js","webpack:///./src/modules/elementRoutines.js","webpack:///./src/modules/buffer.js","webpack:///./src/modules/padding.js","webpack:///./src/modules/viewport.js","webpack:///./src/modules/adapter.js","webpack:///./src/ui-scroll.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","JQLiteExtras","element","convertToPx","css","getStyle","isWindow","scrollTo","self","direction","elem","top","left","method","prop","preserve","isValueDefined","document","documentElement","getWidthHeight","measure","result","measurements","base","borderA","borderB","computedMarginA","computedMarginB","computedStyle","dirA","dirB","paddingA","paddingB","height","width","padding","border","margin","offsetWidth","offsetHeight","getMeasurements","outer","outerfull","style","parseFloat","angular","this","nodeType","obj","location","alert","setInterval","window","getComputedStyle","currentStyle","rs","rsLeft","RegExp","source","test","runtimeStyle","pixelLeft","forEach","before","newElem","children","j","parent","ref","contents","prepend","length","after","Error","outerHTML","isNumber","outerHeight","option","outerWidth","offset","docElem","win","box","doc","ownerDocument","arguments","undefined","getBoundingClientRect","defaultView","parentWindow","pageYOffset","scrollTop","clientTop","pageXOffset","scrollLeft","clientLeft","ElementRoutines","$injector","$q","$animate","has","isAngularVersionLessThen1_3","version","major","minor","index","sheet","styleSheets","cssRules","err","insertRule","selector","addRule","wrapper","addClass","removeClass","newElement","previousElement","remove","scope","$destroy","insertElement","deferred","defer","enter","resolve","promise","removeElement","leave","then","ScrollBuffer","elementRoutines","bufferSize","startIndex","buffer","Array","extend","size","reset","eof","bof","first","next","minIndex","maxIndex","minIndexUser","maxIndexUser","append","items","item","insert","Math","max","immutableTop","reverse","min","operation","isTop","op","splice","push","unshift","arg1","arg2","indexOf","_op","getAbsMinIndex","incrementMinIndex","decrementMaxIndex","removeElementAnimated","getAbsMaxIndex","effectiveHeight","elements","Number","MAX_VALUE","bottom","NEGATIVE_INFINITY","offsetParent","getItems","filter","getFirstItem","list","getLastItem","CacheProto","$index","sort","a","b","argument","_isTop","Cache","instance","apply","setPrototypeOf","getOwnPropertyNames","methodName","Padding","template","Node","ELEMENT_NODE","tagName","toLowerCase","find","generateElement","cache","Viewport","viewportController","$rootScope","topPadding","bottomPadding","viewport","container","bufferPadding","getScope","createPaddingElements","applyContainerStyle","bottomDataPos","scrollHeight","topDataPos","bottomVisiblePos","topVisiblePos","e","sibling","insertElementAnimated","shouldLoadBottom","clipBottom","overage","overageHeight","itemHeight","emptySpaceHeight","add","adjustPaddings","shouldLoadTop","clipTop","visibleItemsHeight","reduce","summ","topPaddingHeight","topCount","bottomPaddingHeight","bottomCount","averageItemHeight","adjustTopPadding","adjustBottomPadding","topPaddingHeightAdd","bottomPaddingHeightAdd","onAfterMinIndexSet","topPaddingHeightOld","diff","onAfterPrepend","updates","prepended","paddingHeight","position","newPosition","synthetic","previous","resetTopPadding","clear","resetBottomPadding","removeCacheItem","removeItem","Adapter","$scope","$parse","$attr","doAdjust","reload","isLoading","disabled","viewportScope","startScope","$parent","publicContext","assignAdapter","adapter","generatePublicContext","adapterAttr","replace","adapterOnScope","assign","error","message","publicMethods","publicProps","attr","set","publicPropsImmediate","newItems","options","arg3","applyUpdatesFunc","applyUpdatesIndex","cb","slice","applyUpdate","_index","isArray","some","newItem","rowTop","topHeight","topDone","bottomDone","itemTop","isEOF","constant","run","elt","jQuery","fn","jquery","registerFor","addCSSRules","directive","restrict","controller","child","console","$timeout","$interval","require","transclude","priority","terminal","link","controllers","linker","match","uiScroll","parseNumber","defaultValue","isFloat","floor","isNaN","parseNumericAttr","datasource","itemName","datasourceName","handleInertia","ridActual","pending","unbindEvents","persistDatasourceIndex","isDatasourceValid","toString","onRenderHandlers","propName","handler","id","defineDatasourceIndex","propUserName","descriptor","getOwnPropertyDescriptor","fetchNext","success","count","fetchPrevious","isInvalid","rid","$$destroyed","off","resizeAndScrollHandler","isElementVisible","insertWrapperContent","insertAfter","createElement","unregisterVisibilityWatcher","$watch","visibilityWatcher","hideElement","promises","clone","transform","tdInitializer","uiScrollTdInitializer","linking","onLink","updatePaddings","animated","all","enqueueFetch","inserted","loading","fetch","processUpdates","toBePrepended","toBeRemoved","concat","removed","$$phase","$digest","w","showElement","calculateProperties","doAdjustAfterFetch","shift","on","oldPosition","requestAnimationFrame","fixInertia","wheelHandler","event","yMax","clientHeight","preventDefault","$on","tryCount","timer","cancel","initialize"],"mappings":"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","file":"ui-scroll.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","/*!\r\n globals: angular, window\r\n List of used element methods available in JQuery but not in JQuery Lite\r\n element.before(elem)\r\n element.height()\r\n element.outerHeight(true)\r\n element.height(value) = only for Top/Bottom padding elements\r\n element.scrollTop()\r\n element.scrollTop(value)\r\n */\r\n\r\nexport default class JQLiteExtras {\r\n\r\n  registerFor(element) {\r\n    let convertToPx, css, getStyle, isWindow;\r\n    // angular implementation blows up if elem is the window\r\n    css = angular.element.prototype.css;\r\n\r\n    element.prototype.css = function (name, value) {\r\n      let self = this;\r\n      let elem = self[0];\r\n      if (!(!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style)) {\r\n        return css.call(self, name, value);\r\n      }\r\n    };\r\n\r\n    // as defined in angularjs v1.0.5\r\n    isWindow = (obj) => obj && obj.document && obj.location && obj.alert && obj.setInterval;\r\n\r\n    function scrollTo(self, direction, value) {\r\n      let elem = self[0];\r\n      let [method, prop, preserve] = {\r\n        top: [\r\n          'scrollTop',\r\n          'pageYOffset',\r\n          'scrollLeft'\r\n        ],\r\n        left: [\r\n          'scrollLeft',\r\n          'pageXOffset',\r\n          'scrollTop'\r\n        ]\r\n      }[direction];\r\n\r\n      const isValueDefined = typeof value !== 'undefined';\r\n      if (isWindow(elem)) {\r\n        if (isValueDefined) {\r\n          return elem.scrollTo(self[preserve].call(self), value);\r\n        }\r\n        return (prop in elem) ? elem[prop] : elem.document.documentElement[method];\r\n      } else {\r\n        if (isValueDefined) {\r\n          elem[method] = value;\r\n        }\r\n        return elem[method];\r\n      }\r\n    }\r\n\r\n    if (window.getComputedStyle) {\r\n      getStyle = (elem) => window.getComputedStyle(elem, null);\r\n      convertToPx = (elem, value) => parseFloat(value);\r\n    } else {\r\n      getStyle = (elem) => elem.currentStyle;\r\n      convertToPx = (elem, value) => {\r\n        let left, result, rs, rsLeft, style;\r\n        let core_pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\r\n        let rnumnonpx = new RegExp('^(' + core_pnum + ')(?!px)[a-z%]+$', 'i');\r\n\r\n        if (!rnumnonpx.test(value)) {\r\n          return parseFloat(value);\r\n        }\r\n\r\n        // ported from JQuery\r\n        style = elem.style;\r\n        left = style.left;\r\n        rs = elem.runtimeStyle;\r\n        rsLeft = rs && rs.left;\r\n        if (rs) {\r\n          rs.left = style.left;\r\n        }\r\n        // put in the new values to get a computed style out\r\n        style.left = value;\r\n        result = style.pixelLeft;\r\n        style.left = left;\r\n        if (rsLeft) {\r\n          rs.left = rsLeft;\r\n        }\r\n        return result;\r\n      };\r\n    }\r\n\r\n    function getMeasurements(elem, measure) {\r\n      let base, borderA, borderB, computedMarginA, computedMarginB, computedStyle, dirA, dirB, marginA, marginB, paddingA, paddingB;\r\n\r\n      if (isWindow(elem)) {\r\n        base = document.documentElement[{height: 'clientHeight', width: 'clientWidth'}[measure]];\r\n\r\n        return {\r\n          base: base,\r\n          padding: 0,\r\n          border: 0,\r\n          margin: 0\r\n        };\r\n      }\r\n\r\n      // Start with offset property\r\n      [\r\n        base,\r\n        dirA,\r\n        dirB\r\n      ] = {\r\n        width: [\r\n          elem.offsetWidth,\r\n          'Left',\r\n          'Right'\r\n        ],\r\n        height: [\r\n          elem.offsetHeight,\r\n          'Top',\r\n          'Bottom'\r\n        ]\r\n      }[measure];\r\n\r\n      computedStyle = getStyle(elem);\r\n      paddingA = convertToPx(elem, computedStyle['padding' + dirA]) || 0;\r\n      paddingB = convertToPx(elem, computedStyle['padding' + dirB]) || 0;\r\n      borderA = convertToPx(elem, computedStyle['border' + dirA + 'Width']) || 0;\r\n      borderB = convertToPx(elem, computedStyle['border' + dirB + 'Width']) || 0;\r\n      computedMarginA = computedStyle['margin' + dirA];\r\n      computedMarginB = computedStyle['margin' + dirB];\r\n\r\n      // I do not care for width for now, so this hack is irrelevant\r\n      // if ( !supportsPercentMargin )\r\n      // computedMarginA = hackPercentMargin( elem, computedStyle, computedMarginA )\r\n      // computedMarginB = hackPercentMargin( elem, computedStyle, computedMarginB )\r\n      marginA = convertToPx(elem, computedMarginA) || 0;\r\n      marginB = convertToPx(elem, computedMarginB) || 0;\r\n\r\n      return {\r\n        base: base,\r\n        padding: paddingA + paddingB,\r\n        border: borderA + borderB,\r\n        margin: marginA + marginB\r\n      };\r\n    }\r\n\r\n    function getWidthHeight(elem, direction, measure) {\r\n      let computedStyle, result;\r\n\r\n      let measurements = getMeasurements(elem, direction);\r\n\r\n      if (measurements.base > 0) {\r\n        return {\r\n          base: measurements.base - measurements.padding - measurements.border,\r\n          outer: measurements.base,\r\n          outerfull: measurements.base + measurements.margin\r\n        }[measure];\r\n      }\r\n\r\n      // Fall back to computed then uncomputed css if necessary\r\n      computedStyle = getStyle(elem);\r\n      result = computedStyle[direction];\r\n\r\n      if (result < 0 || result === null) {\r\n        result = elem.style[direction] || 0;\r\n      }\r\n\r\n      // Normalize \"\", auto, and prepare for extra\r\n      result = parseFloat(result) || 0;\r\n\r\n      return {\r\n        base: result - measurements.padding - measurements.border,\r\n        outer: result,\r\n        outerfull: result + measurements.padding + measurements.border + measurements.margin\r\n      }[measure];\r\n    }\r\n\r\n    // define missing methods\r\n    return angular.forEach({\r\n      before(newElem) {\r\n        var children, elem, i, j, parent, ref, self;\r\n        self = this;\r\n        elem = self[0];\r\n        parent = self.parent();\r\n        children = parent.contents();\r\n        if (children[0] === elem) {\r\n          return parent.prepend(newElem);\r\n        } else {\r\n          for (i = j = 1, ref = children.length - 1; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {\r\n            if (children[i] === elem) {\r\n              angular.element(children[i - 1]).after(newElem);\r\n              return;\r\n            }\r\n          }\r\n          throw new Error('invalid DOM structure ' + elem.outerHTML);\r\n        }\r\n      },\r\n      height (value){\r\n        var self;\r\n        self = this;\r\n        if (typeof value !== 'undefined') {\r\n          if (angular.isNumber(value)) {\r\n            value = value + 'px';\r\n          }\r\n          return css.call(self, 'height', value);\r\n        } else {\r\n          return getWidthHeight(this[0], 'height', 'base');\r\n        }\r\n      },\r\n      outerHeight(option) {\r\n        return getWidthHeight(this[0], 'height', option ? 'outerfull' : 'outer');\r\n      },\r\n      outerWidth(option) {\r\n        return getWidthHeight(this[0], 'width', option ? 'outerfull' : 'outer');\r\n      },\r\n\r\n      /*\r\n       The offset setter method is not implemented\r\n       */\r\n      offset(value) {\r\n        let docElem, win;\r\n        let self = this;\r\n        let box = {\r\n          top: 0,\r\n          left: 0\r\n        };\r\n        let elem = self[0];\r\n        let doc = elem && elem.ownerDocument;\r\n\r\n        if (arguments.length) {\r\n          if (value === undefined) {\r\n            return self;\r\n          }\r\n          // TODO: implement setter\r\n          throw new Error('offset setter method is not implemented');\r\n        }\r\n\r\n        if (!doc) {\r\n          return;\r\n        }\r\n\r\n        docElem = doc.documentElement;\r\n\r\n        // TODO: Make sure it's not a disconnected DOM node\r\n\r\n        if (elem.getBoundingClientRect != null) {\r\n          box = elem.getBoundingClientRect();\r\n        }\r\n\r\n        win = doc.defaultView || doc.parentWindow;\r\n\r\n        return {\r\n          top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),\r\n          left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)\r\n        };\r\n      },\r\n      scrollTop(value) {\r\n        return scrollTo(this, 'top', value);\r\n      },\r\n      scrollLeft(value) {\r\n        return scrollTo(this, 'left', value);\r\n      }\r\n    }, (value, key) => {\r\n      if (!element.prototype[key]) {\r\n        return element.prototype[key] = value;\r\n      }\r\n    });\r\n  }\r\n\r\n}\r\n","const hideClassToken = 'ng-ui-scroll-hide';\r\n\r\nexport default class ElementRoutines {\r\n\r\n  static addCSSRules() {\r\n    const selector = '.' + hideClassToken;\r\n    const rules = 'display: none';\r\n    const sheet = document.styleSheets[0];\r\n    let index;\r\n    try {\r\n      index = sheet.cssRules.length;\r\n    } catch (err) {\r\n      index = 0;\r\n    }\r\n    if('insertRule' in sheet) {\r\n      sheet.insertRule(selector + '{' + rules + '}', index);\r\n    }\r\n    else if('addRule' in sheet) {\r\n      sheet.addRule(selector, rules, index);\r\n    }\r\n  }\r\n\r\n  constructor($injector, $q) {\r\n    this.$animate = ($injector.has && $injector.has('$animate')) ? $injector.get('$animate') : null;\r\n    this.isAngularVersionLessThen1_3 = angular.version.major === 1 && angular.version.minor < 3;\r\n    this.$q = $q;\r\n  }\r\n\r\n  hideElement(wrapper) {\r\n    wrapper.element.addClass(hideClassToken);\r\n  }\r\n\r\n  showElement(wrapper) {\r\n    wrapper.element.removeClass(hideClassToken);\r\n  }\r\n\r\n  insertElement(newElement, previousElement) {\r\n    previousElement.after(newElement);\r\n    return [];\r\n  }\r\n\r\n  removeElement(wrapper) {\r\n    wrapper.element.remove();\r\n    wrapper.scope.$destroy();\r\n    return [];\r\n  }\r\n\r\n  insertElementAnimated(newElement, previousElement) {\r\n    if (!this.$animate) {\r\n      return this.insertElement(newElement, previousElement);\r\n    }\r\n\r\n    if (this.isAngularVersionLessThen1_3) {\r\n      const deferred = this.$q.defer();\r\n      // no need for parent - previous element is never null\r\n      this.$animate.enter(newElement, null, previousElement, () => deferred.resolve());\r\n\r\n      return [deferred.promise];\r\n    }\r\n\r\n    // no need for parent - previous element is never null\r\n    return [this.$animate.enter(newElement, null, previousElement)];\r\n  }\r\n\r\n  removeElementAnimated(wrapper) {\r\n    if (!this.$animate) {\r\n      return this.removeElement(wrapper);\r\n    }\r\n\r\n    if (this.isAngularVersionLessThen1_3) {\r\n      const deferred = this.$q.defer();\r\n      this.$animate.leave(wrapper.element, () => {\r\n        wrapper.scope.$destroy();\r\n        return deferred.resolve();\r\n      });\r\n\r\n      return [deferred.promise];\r\n    }\r\n\r\n    return [(this.$animate.leave(wrapper.element)).then(() => wrapper.scope.$destroy())];\r\n  }\r\n}","export default function ScrollBuffer(elementRoutines, bufferSize, startIndex) {\r\n  const buffer = Object.create(Array.prototype);\r\n\r\n  angular.extend(buffer, {\r\n    size: bufferSize,\r\n\r\n    reset(startIndex) {\r\n      buffer.remove(0, buffer.length);\r\n      buffer.eof = false;\r\n      buffer.bof = false;\r\n      buffer.first = startIndex;\r\n      buffer.next = startIndex;\r\n      buffer.minIndex = startIndex;\r\n      buffer.maxIndex = startIndex;\r\n      buffer.minIndexUser = null;\r\n      buffer.maxIndexUser = null;\r\n    },\r\n\r\n    append(items) {\r\n      items.forEach((item) => {\r\n        ++buffer.next;\r\n        buffer.insert('append', item);\r\n      });\r\n      buffer.maxIndex = buffer.eof ? buffer.next - 1 : Math.max(buffer.next - 1, buffer.maxIndex);\r\n    },\r\n\r\n    prepend(items, immutableTop) {\r\n      items.reverse().forEach((item) => {\r\n        if (immutableTop) {\r\n          ++buffer.next;\r\n        }\r\n        else {\r\n          --buffer.first;\r\n        }\r\n        buffer.insert('prepend', item);\r\n      });\r\n      buffer.minIndex = buffer.bof ? buffer.minIndex = buffer.first : Math.min(buffer.first, buffer.minIndex);\r\n    },\r\n\r\n    /**\r\n     * inserts wrapped element in the buffer\r\n     * the first argument is either operation keyword (see below) or a number for operation 'insert'\r\n     * for insert the number is the index for the buffer element the new one have to be inserted after\r\n     * operations: 'append', 'prepend', 'insert', 'remove', 'update', 'none'\r\n     */\r\n    insert(operation, item, isTop) {\r\n      const wrapper = {\r\n        item: item\r\n      };\r\n\r\n      if (operation % 1 === 0) {// it is an insert\r\n        wrapper.op = 'insert';\r\n        buffer.splice(operation, 0, wrapper);\r\n        if(isTop) {\r\n          buffer.first--;\r\n        }\r\n        else {\r\n          buffer.next++;\r\n        }\r\n      } else {\r\n        wrapper.op = operation;\r\n        switch (operation) {\r\n          case 'append':\r\n            buffer.push(wrapper);\r\n            break;\r\n          case 'prepend':\r\n            buffer.unshift(wrapper);\r\n            break;\r\n        }\r\n      }\r\n    },\r\n\r\n    // removes elements from buffer\r\n    remove(arg1, arg2) {\r\n      if (angular.isNumber(arg1)) {\r\n        // removes items from arg1 (including) through arg2 (excluding)\r\n        for (let i = arg1; i < arg2; i++) {\r\n          elementRoutines.removeElement(buffer[i]);\r\n        }\r\n        return buffer.splice(arg1, arg2 - arg1);\r\n      }\r\n      // removes single item(wrapper) from the buffer\r\n      buffer.splice(buffer.indexOf(arg1), 1);\r\n      if(arg1._op === 'isTop' && buffer.first === this.getAbsMinIndex()) {\r\n        this.incrementMinIndex();\r\n      }\r\n      else {\r\n        this.decrementMaxIndex();\r\n      }\r\n      if(arg1._op === 'isTop') {\r\n        buffer.first++;\r\n      }\r\n      else {\r\n        buffer.next--;\r\n      }\r\n      if(!buffer.length) {\r\n        buffer.first = 1;\r\n        buffer.next = 1;\r\n      }\r\n\r\n      return elementRoutines.removeElementAnimated(arg1);\r\n    },\r\n\r\n    incrementMinIndex() {\r\n      if(buffer.minIndexUser !== null) {\r\n        if(buffer.minIndex > buffer.minIndexUser) {\r\n          buffer.minIndexUser++;\r\n          return;\r\n        }\r\n        if(buffer.minIndex === buffer.minIndexUser) {\r\n          buffer.minIndexUser++;\r\n        }\r\n      }\r\n      buffer.minIndex++;\r\n    },\r\n\r\n    decrementMaxIndex() {\r\n      if(buffer.maxIndexUser !== null && buffer.maxIndex <= buffer.maxIndexUser) {\r\n        buffer.maxIndexUser--;\r\n      }\r\n      buffer.maxIndex--;\r\n    },\r\n\r\n    getAbsMinIndex() {\r\n      if(buffer.minIndexUser !== null) {\r\n        return Math.min(buffer.minIndexUser, buffer.minIndex);\r\n      }\r\n      return buffer.minIndex;\r\n    },\r\n\r\n    getAbsMaxIndex() {\r\n      if(buffer.maxIndexUser !== null) {\r\n        return Math.max(buffer.maxIndexUser, buffer.maxIndex);\r\n      }\r\n      return buffer.maxIndex;\r\n    },\r\n\r\n    effectiveHeight(elements) {\r\n      if (!elements.length) {\r\n        return 0;\r\n      }\r\n      let top = Number.MAX_VALUE;\r\n      let bottom = Number.NEGATIVE_INFINITY;\r\n      elements.forEach((wrapper) => {\r\n        if (wrapper.element[0].offsetParent) {\r\n          // element style is not display:none\r\n          top = Math.min(top, wrapper.element.offset().top);\r\n          bottom = Math.max(bottom, wrapper.element.offset().top + wrapper.element.outerHeight(true));\r\n        }\r\n      });\r\n      return Math.max(0, bottom - top);\r\n    },\r\n\r\n    getItems() {\r\n      return buffer.filter(item => item.op === 'none');\r\n    },\r\n\r\n    getFirstItem() {\r\n      const list = buffer.getItems();\r\n      if (!list.length) {\r\n        return null;\r\n      }\r\n      return list[0].item;\r\n    },\r\n\r\n    getLastItem() {\r\n      const list = buffer.getItems();\r\n      if (!list.length) {\r\n        return null;\r\n      }\r\n      return list[list.length - 1].item;\r\n    }\r\n\r\n  });\r\n\r\n  buffer.reset(startIndex);\r\n\r\n  return buffer;\r\n}\r\n","// Can't just extend the Array, due to Babel does not support built-in classes extending\r\n// This solution was taken from https://stackoverflow.com/questions/46897414/es6-class-extends-array-workaround-for-es5-babel-transpile\r\nclass CacheProto {\r\n  add(item) {\r\n    for (let i = this.length - 1; i >= 0; i--) {\r\n      if (this[i].index === item.scope.$index) {\r\n        this[i].height = item.element.outerHeight();\r\n        return;\r\n      }\r\n    }\r\n    this.push({\r\n      index: item.scope.$index,\r\n      height: item.element.outerHeight()\r\n    });\r\n    this.sort((a, b) => ((a.index < b.index) ? -1 : ((a.index > b.index) ? 1 : 0)));\r\n  }\r\n\r\n  remove(argument, _isTop) {\r\n    const index = argument % 1 === 0 ? argument : argument.scope.$index;\r\n    const isTop = argument % 1 === 0 ? _isTop : argument._op === 'isTop';\r\n    for (let i = this.length - 1; i >= 0; i--) {\r\n      if (this[i].index === index) {\r\n        this.splice(i, 1);\r\n        break;\r\n      }\r\n    }\r\n    if(!isTop) {\r\n      for (let i = this.length - 1; i >= 0; i--) {\r\n        if (this[i].index > index) {\r\n          this[i].index--;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  clear() {\r\n    this.length = 0;\r\n  }\r\n}\r\n\r\nfunction Cache() {\r\n  const instance = [];\r\n  instance.push.apply(instance, arguments);\r\n  Object.setPrototypeOf(instance, Cache.prototype);\r\n  return instance;\r\n}\r\nCache.prototype = Object.create(Array.prototype);\r\nObject.getOwnPropertyNames(CacheProto.prototype).forEach(methodName =>\r\n  Cache.prototype[methodName] = CacheProto.prototype[methodName]\r\n);\r\n\r\nfunction generateElement(template) {\r\n  if(template.nodeType !== Node.ELEMENT_NODE) {\r\n    throw new Error('ui-scroll directive requires an Element node for templating the view');\r\n  }\r\n  let element;\r\n  switch (template.tagName.toLowerCase()) {\r\n    case 'dl':\r\n      throw new Error(`ui-scroll directive does not support <${template.tagName}> as a repeating tag: ${template.outerHTML}`);\r\n    case 'tr':\r\n      let table = angular.element('<table><tr><td><div></div></td></tr></table>');\r\n      element = table.find('tr');\r\n      break;\r\n    case 'li':\r\n      element = angular.element('<li></li>');\r\n      break;\r\n    default:\r\n      element = angular.element('<div></div>');\r\n  }\r\n  return element;\r\n}\r\n\r\nclass Padding {\r\n  constructor(template) {\r\n    this.element = generateElement(template);\r\n    this.cache = new Cache();\r\n  }\r\n\r\n  height() {\r\n    return this.element.height.apply(this.element, arguments);\r\n  }\r\n}\r\n\r\nexport default Padding;","import Padding from './padding';\r\n\r\nexport default function Viewport(elementRoutines, buffer, element, viewportController, $rootScope, padding) {\r\n  let topPadding = null;\r\n  let bottomPadding = null;\r\n  const viewport = viewportController && viewportController.viewport ? viewportController.viewport : angular.element(window);\r\n  const container = viewportController && viewportController.container ? viewportController.container : undefined;\r\n  const scope = viewportController && viewportController.scope ? viewportController.scope : $rootScope;\r\n\r\n  viewport.css({\r\n    'overflow-anchor': 'none',\r\n    'overflow-y': 'auto',\r\n    'display': 'block'\r\n  });\r\n\r\n  function bufferPadding() {\r\n    return viewport.outerHeight() * padding; // some extra space to initiate preload\r\n  }\r\n\r\n  angular.extend(viewport, {\r\n    getScope() {\r\n      return scope;\r\n    },\r\n\r\n    createPaddingElements(template) {\r\n      topPadding = new Padding(template);\r\n      bottomPadding = new Padding(template);\r\n      element.before(topPadding.element);\r\n      element.after(bottomPadding.element);\r\n      topPadding.height(0);\r\n      bottomPadding.height(0);\r\n    },\r\n\r\n    applyContainerStyle() {\r\n      if (!container) {\r\n        return true;\r\n      }\r\n      if(container !== viewport) {\r\n        viewport.css('height', window.getComputedStyle(container[0]).height);\r\n      }\r\n      return viewport.height() > 0;\r\n    },\r\n\r\n    bottomDataPos() {\r\n      let scrollHeight = viewport[0].scrollHeight;\r\n      scrollHeight = scrollHeight != null ? scrollHeight : viewport[0].document.documentElement.scrollHeight;\r\n      return scrollHeight - bottomPadding.height();\r\n    },\r\n\r\n    topDataPos() {\r\n      return topPadding.height();\r\n    },\r\n\r\n    bottomVisiblePos() {\r\n      return viewport.scrollTop() + viewport.outerHeight();\r\n    },\r\n\r\n    topVisiblePos() {\r\n      return viewport.scrollTop();\r\n    },\r\n\r\n    insertElement(e, sibling) {\r\n      return elementRoutines.insertElement(e, sibling || topPadding.element);\r\n    },\r\n\r\n    insertElementAnimated(e, sibling) {\r\n      return elementRoutines.insertElementAnimated(e, sibling || topPadding.element);\r\n    },\r\n\r\n    shouldLoadBottom() {\r\n      return !buffer.eof && viewport.bottomDataPos() < viewport.bottomVisiblePos() + bufferPadding();\r\n    },\r\n\r\n    clipBottom() {\r\n      // clip the invisible items off the bottom\r\n      let overage = 0;\r\n      let overageHeight = 0;\r\n      let itemHeight = 0;\r\n      let emptySpaceHeight = viewport.bottomDataPos() - viewport.bottomVisiblePos() - bufferPadding();\r\n\r\n      for (let i = buffer.length - 1; i >= 0; i--) {\r\n        itemHeight = buffer[i].element.outerHeight(true);\r\n        if (overageHeight + itemHeight > emptySpaceHeight) {\r\n          break;\r\n        }\r\n        bottomPadding.cache.add(buffer[i]);\r\n        overageHeight += itemHeight;\r\n        overage++;\r\n      }\r\n\r\n      if (overage > 0) {\r\n        buffer.eof = false;\r\n        buffer.remove(buffer.length - overage, buffer.length);\r\n        buffer.next -= overage;\r\n        viewport.adjustPaddings();\r\n      }\r\n    },\r\n\r\n    shouldLoadTop() {\r\n      return !buffer.bof && (viewport.topDataPos() > viewport.topVisiblePos() - bufferPadding());\r\n    },\r\n\r\n    clipTop() {\r\n      // clip the invisible items off the top\r\n      let overage = 0;\r\n      let overageHeight = 0;\r\n      let itemHeight = 0;\r\n      let emptySpaceHeight = viewport.topVisiblePos() - viewport.topDataPos() - bufferPadding();\r\n\r\n      for (let i = 0; i < buffer.length; i++) {\r\n        itemHeight = buffer[i].element.outerHeight(true);\r\n        if (overageHeight + itemHeight > emptySpaceHeight) {\r\n          break;\r\n        }\r\n        topPadding.cache.add(buffer[i]);\r\n        overageHeight += itemHeight;\r\n        overage++;\r\n      }\r\n\r\n      if (overage > 0) {\r\n        // we need to adjust top padding element before items are removed from top\r\n        // to avoid strange behaviour of scroll bar during remove top items when we are at the very bottom\r\n        topPadding.height(topPadding.height() + overageHeight);\r\n        buffer.bof = false;\r\n        buffer.remove(0, overage);\r\n        buffer.first += overage;\r\n      }\r\n    },\r\n\r\n    adjustPaddings() {\r\n      if (!buffer.length) {\r\n        return;\r\n      }\r\n\r\n      // precise heights calculation based on items that are in buffer or that were in buffer once\r\n      const visibleItemsHeight = buffer.reduce((summ, item) => summ + item.element.outerHeight(true), 0);\r\n\r\n      let topPaddingHeight = 0, topCount = 0;\r\n      topPadding.cache.forEach(item => {\r\n        if(item.index < buffer.first) {\r\n          topPaddingHeight += item.height;\r\n          topCount++;\r\n        }\r\n      });\r\n\r\n      let bottomPaddingHeight = 0, bottomCount = 0;\r\n      bottomPadding.cache.forEach(item => {\r\n        if(item.index >= buffer.next) {\r\n          bottomPaddingHeight += item.height;\r\n          bottomCount++;\r\n        }\r\n      });\r\n\r\n      const totalHeight = visibleItemsHeight + topPaddingHeight + bottomPaddingHeight;\r\n      const averageItemHeight = totalHeight / (topCount + bottomCount + buffer.length);\r\n\r\n      // average heights calculation, items that have never been reached\r\n      let adjustTopPadding = buffer.minIndexUser !== null && buffer.minIndex > buffer.minIndexUser;\r\n      let adjustBottomPadding = buffer.maxIndexUser !== null && buffer.maxIndex < buffer.maxIndexUser;\r\n      let topPaddingHeightAdd = adjustTopPadding ? (buffer.minIndex - buffer.minIndexUser) * averageItemHeight : 0;\r\n      let bottomPaddingHeightAdd = adjustBottomPadding ? (buffer.maxIndexUser - buffer.maxIndex) * averageItemHeight : 0;\r\n\r\n      // paddings combine adjustment\r\n      topPadding.height(topPaddingHeight + topPaddingHeightAdd);\r\n      bottomPadding.height(bottomPaddingHeight + bottomPaddingHeightAdd);\r\n    },\r\n\r\n    onAfterMinIndexSet(topPaddingHeightOld) {\r\n      // additional scrollTop adjustment in case of datasource.minIndex external set\r\n      if (buffer.minIndexUser !== null && buffer.minIndex > buffer.minIndexUser) {\r\n        let diff = topPadding.height() - topPaddingHeightOld;\r\n        viewport.scrollTop(viewport.scrollTop() + diff);\r\n        while((diff -= viewport.scrollTop()) > 0) {\r\n          bottomPadding.height(bottomPadding.height() + diff);\r\n          viewport.scrollTop(viewport.scrollTop() + diff);\r\n        }\r\n      }\r\n    },\r\n\r\n    onAfterPrepend(updates) {\r\n      if (!updates.prepended.length) {\r\n        return;\r\n      }\r\n      const height = buffer.effectiveHeight(updates.prepended);\r\n      const paddingHeight = topPadding.height() - height;\r\n      if (paddingHeight >= 0) {\r\n        topPadding.height(paddingHeight);\r\n        return;\r\n      }\r\n      const position = viewport.scrollTop();\r\n      const newPosition = position - paddingHeight;\r\n      viewport.synthetic = { previous: position, next: newPosition };\r\n      topPadding.height(0);\r\n      viewport.scrollTop(newPosition);\r\n    },\r\n\r\n    resetTopPadding() {\r\n      topPadding.height(0);\r\n      topPadding.cache.clear();\r\n    },\r\n\r\n    resetBottomPadding() {\r\n      bottomPadding.height(0);\r\n      bottomPadding.cache.clear();\r\n    },\r\n\r\n    removeCacheItem(item, isTop) {\r\n      topPadding.cache.remove(item, isTop);\r\n      bottomPadding.cache.remove(item, isTop);\r\n    },\r\n\r\n    removeItem(item) {\r\n      this.removeCacheItem(item);\r\n      return buffer.remove(item);\r\n    }\r\n  });\r\n\r\n  return viewport;\r\n}\r\n","class Adapter {\r\n\r\n  constructor($scope, $parse, $attr, viewport, buffer, doAdjust, reload) {\r\n    this.$parse = $parse;\r\n    this.$attr = $attr;\r\n    this.viewport = viewport;\r\n    this.buffer = buffer;\r\n\r\n    this.doAdjust = doAdjust;\r\n    this.reload = reload;\r\n\r\n    this.isLoading = false;\r\n    this.disabled = false;\r\n\r\n    const viewportScope = viewport.getScope();\r\n    this.startScope = viewportScope.$parent ? viewportScope : $scope;\r\n\r\n    this.publicContext = {};\r\n    this.assignAdapter($attr.adapter);\r\n    this.generatePublicContext();\r\n  }\r\n\r\n  assignAdapter(adapterAttr) {\r\n    if (!adapterAttr || !(adapterAttr = adapterAttr.replace(/^\\s+|\\s+$/gm, ''))) {\r\n      return;\r\n    }\r\n    let adapterOnScope;\r\n\r\n    try {\r\n      this.$parse(adapterAttr).assign(this.startScope, {});\r\n      adapterOnScope = this.$parse(adapterAttr)(this.startScope);\r\n    }\r\n    catch (error) {\r\n      error.message = `Angular ui-scroll Adapter assignment exception.\\n` +\r\n        `Can't parse \"${adapterAttr}\" expression.\\n` +\r\n        error.message;\r\n      throw error;\r\n    }\r\n\r\n    angular.extend(adapterOnScope, this.publicContext);\r\n    this.publicContext = adapterOnScope;\r\n  }\r\n\r\n  generatePublicContext() {\r\n    // these methods will be accessible out of ui-scroll via user defined adapter\r\n    const publicMethods = ['reload', 'applyUpdates', 'append', 'prepend', 'isBOF', 'isEOF', 'isEmpty'];\r\n    for (let i = publicMethods.length - 1; i >= 0; i--) {\r\n      this.publicContext[publicMethods[i]] = this[publicMethods[i]].bind(this);\r\n    }\r\n\r\n    // these read-only props will be accessible out of ui-scroll via user defined adapter\r\n    const publicProps = ['isLoading', 'topVisible', 'topVisibleElement', 'topVisibleScope', 'bottomVisible', 'bottomVisibleElement', 'bottomVisibleScope'];\r\n    for (let i = publicProps.length - 1; i >= 0; i--) {\r\n      let property, attr = this.$attr[publicProps[i]];\r\n      Object.defineProperty(this, publicProps[i], {\r\n        get: () => property,\r\n        set: (value) => {\r\n          property = value;\r\n          this.publicContext[publicProps[i]] = value;\r\n          if (attr) {\r\n            this.$parse(attr).assign(this.startScope, value);\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    // read-only immediately calculated public properties\r\n    const publicPropsImmediate = ['bufferFirst', 'bufferLast', 'bufferLength'];\r\n    for (let i = publicPropsImmediate.length - 1; i >= 0; i--) {\r\n      Object.defineProperty(this.publicContext, publicPropsImmediate[i], {\r\n        get: () => this[publicPropsImmediate[i]]\r\n      });\r\n    }\r\n\r\n    // non-read-only public property\r\n    Object.defineProperty(this.publicContext, 'disabled', {\r\n      get: () => this.disabled,\r\n      set: (value) => (!(this.disabled = value)) ? this.doAdjust() : null\r\n    });\r\n  }\r\n\r\n  loading(value) {\r\n    this.isLoading = value;\r\n  }\r\n\r\n  isBOF() {\r\n    return this.buffer.bof;\r\n  }\r\n\r\n  isEOF() {\r\n    return this.buffer.eof;\r\n  }\r\n\r\n  isEmpty() {\r\n    return !this.buffer.length;\r\n  }\r\n\r\n  get bufferLength() {\r\n    return this.buffer.getItems().length;\r\n  }\r\n\r\n  get bufferFirst() {\r\n    return this.buffer.getFirstItem();\r\n  }\r\n\r\n  get bufferLast() {\r\n    return this.buffer.getLastItem();\r\n  }\r\n\r\n  append(newItems) {\r\n    this.buffer.append(newItems);\r\n    this.doAdjust();\r\n    this.viewport.clipTop();\r\n    this.viewport.clipBottom();\r\n  }\r\n\r\n  prepend(newItems, options = {}) {\r\n    this.buffer.prepend(newItems, options.immutableTop);\r\n    this.doAdjust();\r\n    this.viewport.clipTop();\r\n    this.viewport.clipBottom();\r\n  }\r\n\r\n  applyUpdates(arg1, arg2, arg3) {\r\n    if (typeof arg1 === 'function') {\r\n      this.applyUpdatesFunc(arg1, arg2);\r\n    } else {\r\n      this.applyUpdatesIndex(arg1, arg2, arg3);\r\n    }\r\n    this.doAdjust();\r\n  }\r\n\r\n  applyUpdatesFunc(cb, options = {}) {\r\n    this.buffer.slice(0).forEach((wrapper) => {\r\n      // we need to do it on the buffer clone, because buffer content\r\n      // may change as we iterate through\r\n      this.applyUpdate(wrapper, cb(wrapper.item, wrapper.scope, wrapper.element), options);\r\n    });\r\n  }\r\n\r\n  applyUpdatesIndex(index, newItems, options = {}) {\r\n    if (index % 1 !== 0) {\r\n      throw new Error('applyUpdates - ' + index + ' is not a valid index (should be an integer)');\r\n    }\r\n    const _index = index - this.buffer.first;\r\n\r\n    // apply updates only within buffer\r\n    if (_index >= 0 && _index < this.buffer.length) {\r\n      this.applyUpdate(this.buffer[_index], newItems, options);\r\n    }\r\n    // out-of-buffer case: deletion may affect Paddings\r\n    else if(index >= this.buffer.getAbsMinIndex() && index <= this.buffer.getAbsMaxIndex()) {\r\n      if(angular.isArray(newItems) && !newItems.length) {\r\n        this.viewport.removeCacheItem(index, !options.immutableTop && index === this.buffer.minIndex);\r\n        if (!options.immutableTop && index === this.buffer.getAbsMinIndex()) {\r\n          this.buffer.incrementMinIndex();\r\n        }\r\n        else {\r\n          this.buffer.decrementMaxIndex();\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  applyUpdate(wrapper, newItems, options = {}) {\r\n    if (!angular.isArray(newItems)) {\r\n      return;\r\n    }\r\n    let position = this.buffer.indexOf(wrapper);\r\n    if (!newItems.reverse().some(newItem => newItem === wrapper.item)) {\r\n      wrapper.op = 'remove';\r\n      if (!options.immutableTop && position === 0 && !newItems.length) {\r\n        wrapper._op = 'isTop'; // to catch \"first\" edge case on remove\r\n      }\r\n    }\r\n    newItems.forEach((newItem) => {\r\n      if (newItem === wrapper.item) {\r\n        position--;\r\n      } else {\r\n        // 3 parameter (isTop) is to catch \"first\" edge case on insert\r\n        this.buffer.insert(position + 1, newItem, !options.immutableTop && position === -1);\r\n      }\r\n    });\r\n  }\r\n\r\n  calculateProperties() {\r\n    let rowTop = null, topHeight = 0;\r\n    let topDone = false, bottomDone = false;\r\n    const length = this.buffer.length;\r\n\r\n    for (let i = 0; i < length; i++) {\r\n      const item = this.buffer[i];\r\n      const itemTop = item.element.offset().top;\r\n\r\n      if (rowTop !== itemTop) { // a new row condition\r\n        const itemHeight = item.element.outerHeight(true);\r\n        const top = this.viewport.topDataPos() + topHeight + itemHeight;\r\n\r\n        if (!topDone && top > this.viewport.topVisiblePos()) {\r\n          topDone = true;\r\n          this['topVisible'] = item.item;\r\n          this['topVisibleElement'] = item.element;\r\n          this['topVisibleScope'] = item.scope;\r\n        }\r\n        if (!bottomDone && (top >= this.viewport.bottomVisiblePos() || (i === length - 1 && this.isEOF()))) {\r\n          bottomDone = true;\r\n          this['bottomVisible'] = item.item;\r\n          this['bottomVisibleElement'] = item.element;\r\n          this['bottomVisibleScope'] = item.scope;\r\n        }\r\n        topHeight += itemHeight;\r\n      }\r\n      rowTop = itemTop;\r\n\r\n      if (topDone && bottomDone) {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport default Adapter;\r\n","import JQLiteExtras from './modules/jqLiteExtras';\nimport ElementRoutines from './modules/elementRoutines.js';\nimport ScrollBuffer from './modules/buffer.js';\nimport Viewport from './modules/viewport.js';\nimport Adapter from './modules/adapter.js';\n\nangular.module('ui.scroll', [])\n\n  .constant('JQLiteExtras', JQLiteExtras)\n  .run(['JQLiteExtras', (JQLiteExtras) => {\n    const elt = angular.element;\n    !(window.jQuery && elt.fn && elt.fn.jquery) ? (new JQLiteExtras()).registerFor(elt) : null;\n    ElementRoutines.addCSSRules();\n  }])\n\n  .directive('uiScrollViewport', function () {\n    return {\n      restrict: 'A',\n      controller: [\n        '$scope',\n        '$element',\n        function (scope, element) {\n          this.container = element;\n          this.viewport = element;\n          this.scope = scope;\n\n          angular.forEach(element.children(), child => {\n            if (child.tagName.toLowerCase() === 'tbody') {\n              this.viewport = angular.element(child);\n            }\n          });\n\n          return this;\n        }\n      ]\n    };\n  })\n\n  .directive('uiScroll', [\n    '$log',\n    '$injector',\n    '$rootScope',\n    '$timeout',\n    '$interval',\n    '$q',\n    '$parse',\n    function (console, $injector, $rootScope, $timeout, $interval, $q, $parse) {\n\n      return {\n        require: ['?^uiScrollViewport'],\n        restrict: 'A',\n        transclude: 'element',\n        priority: 1000,\n        terminal: true,\n        link: link\n      };\n\n      function link($scope, element, $attr, controllers, linker) {\n        const match = $attr.uiScroll.match(/^\\s*(\\w+)\\s+in\\s+([(\\w|\\$)\\.]+)\\s*$/);\n        if (!match) {\n          throw new Error('Expected uiScroll in form of \\'_item_ in _datasource_\\' but got \\'' + $attr.uiScroll + '\\'');\n        }\n\n        function parseNumber(value, defaultValue, isFloat) {\n          if (!isFloat) {\n            value = value === null ? defaultValue : Math.floor(value);\n          }\n          return isNaN(value) ? defaultValue : value;\n        }\n\n        function parseNumericAttr(value, defaultValue, isFloat) {\n          const result = $parse(value)($scope);\n          return parseNumber(result, defaultValue, isFloat);\n        }\n\n        function parseBooleanAttr(value, defaultValue) {\n          const result = $parse(value)($scope);\n          return typeof result === 'boolean' ? result : defaultValue;\n        }\n\n        const BUFFER_MIN = 3;\n        const BUFFER_DEFAULT = 10;\n        const PADDING_MIN = 0.3;\n        const PADDING_DEFAULT = 0.5;\n        const HANDLE_INERTIA_DEFAULT = true;\n        const START_INDEX_DEFAULT = 1;\n        const MAX_VIEWPORT_DELAY = 500;\n        const VIEWPORT_POLLING_INTERVAL = 50;\n\n        let datasource = null;\n        const itemName = match[1];\n        const datasourceName = match[2];\n        const viewportController = controllers[0];\n        const bufferSize = Math.max(BUFFER_MIN, parseNumericAttr($attr.bufferSize, BUFFER_DEFAULT));\n        const padding = Math.max(PADDING_MIN, parseNumericAttr($attr.padding, PADDING_DEFAULT, true));\n        const handleInertia = parseBooleanAttr($attr.handleInertia, HANDLE_INERTIA_DEFAULT);\n        let startIndex = parseNumericAttr($attr.startIndex, START_INDEX_DEFAULT);\n        let ridActual = 0; // current data revision id\n        let pending = [];\n\n        const elementRoutines = new ElementRoutines($injector, $q);\n        const buffer = new ScrollBuffer(elementRoutines, bufferSize, startIndex);\n        const viewport = new Viewport(elementRoutines, buffer, element, viewportController, $rootScope, padding);\n        const adapter = new Adapter($scope, $parse, $attr, viewport, buffer, doAdjust, reload);\n\n        if (viewportController) {\n          viewportController.adapter = adapter;\n        }\n\n        const isDatasourceValid = () =>\n          Object.prototype.toString.call(datasource) === '[object Object]' && typeof datasource.get === 'function';\n\n        datasource = $parse(datasourceName)($scope); // try to get datasource on scope\n        if (!isDatasourceValid()) {\n          datasource = $injector.get(datasourceName); // try to inject datasource as service\n          if (!isDatasourceValid()) {\n            throw new Error(datasourceName + ' is not a valid datasource');\n          }\n        }\n\n        let onRenderHandlers = [];\n        function onRenderHandlersRunner() {\n          onRenderHandlers.forEach(handler => handler.run());\n          onRenderHandlers = [];\n        }\n        function persistDatasourceIndex(datasource, propName) {\n          let getter;\n          // need to postpone min/maxIndexUser processing if the view is empty\n          if(angular.isNumber(datasource[propName])) {\n            getter = datasource[propName];\n            if(angular.isNumber(getter)) {\n              onRenderHandlers = onRenderHandlers.filter(handler => handler.id !== propName);\n              onRenderHandlers.push({\n                id: propName,\n                run: () => datasource[propName] = getter\n              });\n            }\n          }\n        }\n\n        function defineDatasourceIndex(datasource, propName, propUserName) {\n          const descriptor = Object.getOwnPropertyDescriptor(datasource, propName);\n          if (descriptor && (descriptor.set || descriptor.get)) {\n            return;\n          }\n          let getter;\n          persistDatasourceIndex(datasource, propName);\n          Object.defineProperty(datasource, propName, {\n            set: (value) => {\n              getter = value;\n              if(pending.length && !buffer.length) {\n                persistDatasourceIndex(datasource, propName);\n                return;\n              }\n              buffer[propUserName] = value;\n              const topPaddingHeightOld = viewport.topDataPos();\n              viewport.adjustPaddings();\n              if (propName === 'minIndex') {\n                viewport.onAfterMinIndexSet(topPaddingHeightOld);\n              }\n            },\n            get: () => getter\n          });\n        }\n\n        defineDatasourceIndex(datasource, 'minIndex', 'minIndexUser');\n        defineDatasourceIndex(datasource, 'maxIndex', 'maxIndexUser');\n\n        const fetchNext = (datasource.get.length !== 2) ?\n          (success) => datasource.get(buffer.next, bufferSize, success) :\n          (success) => {\n            datasource.get({\n              index: buffer.next,\n              append: buffer.length ? buffer[buffer.length - 1].item : void 0,\n              count: bufferSize\n            }, success);\n          };\n\n        const fetchPrevious = (datasource.get.length !== 2) ?\n          (success) => datasource.get(buffer.first - bufferSize, bufferSize, success) :\n          (success) => {\n            datasource.get({\n              index: buffer.first - bufferSize,\n              prepend: buffer.length ? buffer[0].item : void 0,\n              count: bufferSize\n            }, success);\n          };\n\n        const initialize = () => {\n          let tryCount = 0;\n          if(!viewport.applyContainerStyle()) {\n            const timer = $interval(() => {\n              tryCount++;\n              if(viewport.applyContainerStyle()) {\n                $interval.cancel(timer);\n                doAdjust();\n              }\n              if(tryCount * VIEWPORT_POLLING_INTERVAL >= MAX_VIEWPORT_DELAY) {\n                $interval.cancel(timer);\n                throw Error(`ui-scroll directive requires a viewport with non-zero height in ${MAX_VIEWPORT_DELAY}ms`);\n              }\n            }, VIEWPORT_POLLING_INTERVAL);\n          }\n          else {\n            doAdjust();\n          }\n        };\n\n        /**\n         * Build padding elements\n         *\n         * Calling linker is the only way I found to get access to the tag name of the template\n         * to prevent the directive scope from pollution a new scope is created and destroyed\n         * right after the builder creation is completed\n         */\n        linker((clone, scope) => {\n          viewport.createPaddingElements(clone[0]);\n          // we do not include the clone in the DOM. It means that the nested directives will not\n          // be able to reach the parent directives, but in this case it is intentional because we\n          // created the clone to access the template tag name\n          scope.$destroy();\n          clone.remove();\n        });\n\n        $scope.$on('$destroy', () => {\n          unbindEvents();\n          viewport.off('mousewheel', wheelHandler);\n        });\n\n        viewport.on('mousewheel', wheelHandler);\n\n        initialize();\n\n        /* Private function definitions */\n\n        function isInvalid(rid) {\n          return (rid && rid !== ridActual) || $scope.$$destroyed;\n        }\n\n        function bindEvents() {\n          viewport.on('resize', resizeAndScrollHandler);\n          viewport.on('scroll', resizeAndScrollHandler);\n        }\n\n        function unbindEvents() {\n          viewport.off('resize', resizeAndScrollHandler);\n          viewport.off('scroll', resizeAndScrollHandler);\n        }\n\n        function reload() {\n          unbindEvents();\n          viewport.resetTopPadding();\n          viewport.resetBottomPadding();\n          if (arguments.length) {\n            startIndex = parseNumber(arguments[0], START_INDEX_DEFAULT, false);\n          }\n          buffer.reset(startIndex);\n          persistDatasourceIndex(datasource, 'minIndex');\n          persistDatasourceIndex(datasource, 'maxIndex');\n          doAdjust();\n        }\n\n        function isElementVisible(wrapper) {\n          return wrapper.element.height() && wrapper.element[0].offsetParent;\n        }\n\n        function visibilityWatcher(wrapper) {\n          if (isElementVisible(wrapper)) {\n            buffer.forEach((item) => {\n              if (typeof item.unregisterVisibilityWatcher === 'function') {\n                item.unregisterVisibilityWatcher();\n                delete item.unregisterVisibilityWatcher;\n              }\n            });\n            if (!pending.length) {\n              $timeout(() => doAdjust());\n            }\n          }\n        }\n\n        function insertWrapperContent(wrapper, insertAfter) {\n          createElement(wrapper, insertAfter, viewport.insertElement);\n          if (!isElementVisible(wrapper)) {\n            wrapper.unregisterVisibilityWatcher = wrapper.scope.$watch(() => visibilityWatcher(wrapper));\n          }\n          elementRoutines.hideElement(wrapper); // hide inserted elements before data binding\n        }\n\n        function createElement(wrapper, insertAfter, insertElement) {\n          let promises = null;\n          const sibling = (insertAfter > 0) ? buffer[insertAfter - 1].element : undefined;\n          linker((clone, scope) => {\n            promises = insertElement(clone, sibling);\n            wrapper.element = clone;\n            wrapper.scope = scope;\n            scope[itemName] = wrapper.item;\n          });\n          // ui-scroll-grid apply\n          if (adapter.transform) {\n            const tdInitializer = wrapper.scope.uiScrollTdInitializer;\n            if (tdInitializer && tdInitializer.linking) {\n              adapter.transform(wrapper.scope, wrapper.element);\n            } else {\n              wrapper.scope.uiScrollTdInitializer = {\n                onLink: () => adapter.transform(wrapper.scope, wrapper.element),\n                scope: wrapper.scope\n              };\n            }\n          }\n          return promises;\n        }\n\n        function updateDOM() {\n          let promises = [];\n          const toBePrepended = [];\n          const toBeRemoved = [];\n          const inserted = [];\n\n          buffer.forEach((wrapper, i) => {\n            switch (wrapper.op) {\n              case 'prepend':\n                toBePrepended.unshift(wrapper);\n                break;\n              case 'append':\n                insertWrapperContent(wrapper, i);\n                wrapper.op = 'none';\n                inserted.push(wrapper);\n                break;\n              case 'insert':\n                promises = promises.concat(createElement(wrapper, i, viewport.insertElementAnimated));\n                wrapper.op = 'none';\n                inserted.push(wrapper);\n                break;\n              case 'remove':\n                toBeRemoved.push(wrapper);\n            }\n          });\n\n          toBeRemoved.forEach((wrapper) => promises = promises.concat(viewport.removeItem(wrapper)));\n\n          if (toBePrepended.length)\n            toBePrepended.forEach((wrapper) => {\n              insertWrapperContent(wrapper);\n              wrapper.op = 'none';\n            });\n\n          buffer.forEach((item, i) => item.scope.$index = buffer.first + i);\n\n          return {\n            prepended: toBePrepended,\n            removed: toBeRemoved,\n            inserted: inserted,\n            animated: promises\n          };\n\n        }\n\n        function updatePaddings(rid, updates) {\n          // schedule another doAdjust after animation completion\n          if (updates.animated.length) {\n            $q.all(updates.animated).then(() => {\n              viewport.adjustPaddings();\n              doAdjust(rid);\n            });\n          } else {\n            viewport.adjustPaddings();\n          }\n        }\n\n        function enqueueFetch(rid, updates) {\n          if (viewport.shouldLoadBottom()) {\n            if (!updates || buffer.effectiveHeight(updates.inserted) > 0) {\n              // this means that at least one item appended in the last batch has height > 0\n              if (pending.push(true) === 1) {\n                adapter.loading(true);\n                fetch(rid);\n              }\n            }\n          } else if (viewport.shouldLoadTop()) {\n            if ((!updates || buffer.effectiveHeight(updates.prepended) > 0) || pending[0]) {\n              // this means that at least one item appended in the last batch has height > 0\n              // pending[0] = true means that previous fetch was appending. We need to force at least one prepend\n              // BTW there will always be at least 1 element in the pending array because bottom is fetched first\n              if (pending.push(false) === 1) {\n                adapter.loading(true);\n                fetch(rid);\n              }\n            }\n          }\n        }\n\n        function processUpdates() {\n          const updates = updateDOM();\n\n          // We need the item bindings to be processed before we can do adjustments\n          !$scope.$$phase && !$rootScope.$$phase && $scope.$digest();\n\n          updates.inserted.forEach(w => elementRoutines.showElement(w));\n          updates.prepended.forEach(w => elementRoutines.showElement(w));\n          return updates;\n        }\n\n        function doAdjust(rid) {\n          if (!rid) { // dismiss pending requests\n            pending = [];\n            rid = ++ridActual;\n          }\n\n          const updates = processUpdates();\n\n          if (isInvalid(rid)) {\n            return;\n          }\n\n          updatePaddings(rid, updates);\n          enqueueFetch(rid);\n\n          if (!pending.length) {\n            adapter.calculateProperties();\n          }\n        }\n\n        function doAdjustAfterFetch(rid) {\n          const updates = processUpdates();\n\n          viewport.onAfterPrepend(updates);\n\n          if (isInvalid(rid)) {\n            return;\n          }\n\n          updatePaddings(rid, updates);\n          onRenderHandlersRunner();\n          enqueueFetch(rid, updates);\n          pending.shift();\n\n          if (pending.length)\n            fetch(rid);\n          else {\n            adapter.loading(false);\n            bindEvents();\n            adapter.calculateProperties();\n          }\n        }\n\n        function fetch(rid) {\n          if (pending[0]) {// scrolling down\n            if (buffer.length && !viewport.shouldLoadBottom()) {\n              doAdjustAfterFetch(rid);\n            } else {\n              fetchNext((result) => {\n                if (isInvalid(rid)) {\n                  return;\n                }\n\n                if (result.length < bufferSize) {\n                  buffer.eof = true;\n                }\n\n                if (result.length > 0) {\n                  viewport.clipTop();\n                  buffer.append(result);\n                }\n\n                doAdjustAfterFetch(rid);\n              });\n            }\n          } else {  // scrolling up\n            if (buffer.length && !viewport.shouldLoadTop()) {\n              doAdjustAfterFetch(rid);\n            } else {\n              fetchPrevious((result) => {\n                if (isInvalid(rid)) {\n                  return;\n                }\n\n                if (result.length < bufferSize) {\n                  buffer.bof = true;\n                  // log 'bof is reached'\n                }\n\n                if (result.length > 0) {\n                  if (buffer.length) {\n                    viewport.clipBottom();\n                  }\n                  buffer.prepend(result);\n                }\n\n                doAdjustAfterFetch(rid);\n              });\n            }\n          }\n        }\n\n        function fixInertia() {\n          if (!viewport.synthetic) {\n            return;\n          }\n          const oldPosition = viewport.synthetic.previous;\n          const newPosition = viewport.synthetic.next;\n          if (viewport.scrollTop() !== newPosition) {\n            requestAnimationFrame(() => {\n              const position = viewport.scrollTop();\n              const diff = oldPosition - position;\n              if (diff > 0) { // inertia over synthetic\n                viewport.scrollTop(newPosition - diff);\n              } else {\n                viewport.scrollTop(newPosition);\n              }\n              viewport.synthetic = null;\n            });\n            return true;\n          }\n          viewport.synthetic = null;\n        }\n\n        function resizeAndScrollHandler() {\n          if (handleInertia && fixInertia()) {\n            return;\n          }\n          if (!$rootScope.$$phase && !adapter.isLoading && !adapter.disabled) {\n\n            enqueueFetch(ridActual);\n\n            if (pending.length) {\n              unbindEvents();\n            } else {\n              adapter.calculateProperties();\n              !$scope.$$phase && $scope.$digest();\n            }\n          }\n        }\n\n        function wheelHandler(event) {\n          if (!adapter.disabled) {\n            const scrollTop = viewport[0].scrollTop;\n            const yMax = viewport[0].scrollHeight - viewport[0].clientHeight;\n\n            if ((scrollTop === 0 && !buffer.bof) || (scrollTop === yMax && !buffer.eof)) {\n              event.preventDefault();\n            }\n          }\n        }\n      }\n\n    }\n  ]);\n"],"sourceRoot":""}